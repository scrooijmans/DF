Nginx Reverse Proxy Websocket Authentication - HTTP 403
Asked 9 years, 10 months ago
Modified 2 years, 9 months ago
Viewed 24k times
15

I'm using Nginx as a reverse proxy of a Spring boot application. I also use Websockets with sockjs and stomp messages.

Here is the context configuration.

<websocket:message-broker application-destination-prefix="/app">
<websocket:stomp-endpoint path="/localization" >
<websocket:sockjs/>
</websocket:stomp-endpoint>
<websocket:simple-broker prefix="/topic" />
</websocket:message-broker>
Here is the client code:

var socket = new SockJS(entryPointUrl);
var stompClient = Stomp.over(socket);

var \_this = this;

stompClient.connect({}, function () {
stompClient.subscribe('/app/some-url', function (message) {
// do some stuff
});
});
I also you Spring Security to protect some content.

@Configuration
@Order(4)
public static class FrontendSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/js/**", "/css/**", "/webjars/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage("/login").permitAll()
                .and()
                .logout().permitAll();
    }

}
Everything works great, expect when I run this application behind a Nginx reverse proxy. Here is the reverse configuration:

    proxy_pass http://testsysten:8080;

    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # WebSocket support (nginx 1.4)
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;

    # Max body size
    client_max_body_size 10M;

The connection always fails with a HTTP 403 code.

I'm using version 1.9.7.

Do you have any idea, why the client does not gets authenticated?

I know similar questions, like this one but the solutions do not work at all.

Update
I managed to run the application over HTTP. I need to pass the CSRF token in the Nginx configuration. New configuration is:

    proxy_pass http://testsysten:8080;

    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # Pass the csrf token (see https://de.wikipedia.org/wiki/Cross-Site-Request-Forgery)
    # Default in Spring Boot
    proxy_pass_header X-XSRF-TOKEN;

    # WebSocket support (nginx 1.4)
    proxy_http_version 1.1;

Only missing is redirect over HTTPS. In the Spring logs is see following entry:

o.s.w.s.s.t.h.DefaultSockJsService - Processing transport request: GET http://testsystem:80/localization/226/3mbmu212/websocket
Seems like Nginx Proxy needs to rewrite the to the right port.

nginxspring-securitywebsocketspring-boot
Share
Improve this question
Follow
edited Aug 7, 2017 at 16:29
atfornes's user avatar
atfornes
46855 silver badges2121 bronze badges
asked Dec 7, 2015 at 15:00
schrieveslaach's user avatar
schrieveslaach
1,81911 gold badge1616 silver badges3737 bronze badges
Add a comment
5 Answers
Sorted by:

Highest score (default)
17

I solved the problem by myself. Basically, Nginx needs to pass some additional header values if you want to use Websocket and Spring Security. The following lines need to be added to location section in your Nginx config:

    # Pass the csrf token (see https://de.wikipedia.org/wiki/Cross-Site-Request-Forgery)
    # Default in Spring Boot and required. Without it nginx suppresses the value
    proxy_pass_header X-XSRF-TOKEN;

    # Set origin to the real instance, otherwise a of Spring security check will fail
    # Same value as defined in proxy_pass
    proxy_set_header Origin "http://testsysten:8080";

Share
Improve this answer
Follow
answered Dec 8, 2015 at 12:37
schrieveslaach's user avatar
schrieveslaach
1,81911 gold badge1616 silver badges3737 bronze badges
Sign up to request clarification or add additional context in comments.

1 Comment

Shinebayar G
Over a year ago
Thanks for the find! This also works in general if someone is doing proxy_pass to different hostname + websocket. Without these proxy_pass works but websocket always uses server_name hostname which breaks websocket.
6

The accepted solution did not work for me although I was using a very classical HTTPS configuration:

server {
listen 443 ssl;
location /ws {
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection "upgrade";
proxy_set_header Host $http_host;
proxy_pass http://127.0.0.1:8888;
}
...
The problem is that Spring checks the origin and specifically that code was causing me trouble:

// in org.springframework.web.util.UriComponentsBuilder.adaptFromForwardedHeaders(HttpHeaders):
if ((this.scheme.equals("http") && "80".equals(this.port)) ||
(this.scheme.equals("https") && "443".equals(this.port))) {
this.port = null;
}
In that code the scheme is 'http' and the port is 8888, which is not discarded because it is not the standard port.

The browser however hits https://myserver/ and the 443 port is omitted because it is the default HTTPS one.

Therefore the ports do not match (empty != 8888) and origin check fails.

Either you can disable origin checks in Spring WebSockets:

registry.addHandler( resgisterHandler(), "/ws" ).setAllowedOrigins( "\*" );
or (probably safer) you can add the scheme and port to the NGINX proxy configuration:

    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Port $server_port;

If you are interested, those headers are read in

org.springframework.web.util.UriComponentsBuilder.adaptFromForwardedHeaders(HttpHeaders)
For Spring Boot 2.2.2+
Starting with Spring Boot version 2.2.2 you should be adding following setting for these X-Forwarded-\* headers to be taken into account:

server.forward-headers-strategy=native
(in application.properties for instance)

Share
Improve this answer
Follow
edited Feb 13, 2020 at 10:00
answered Jan 12, 2018 at 10:26
Yann Vo's user avatar
Yann Vo
2,02111 gold badge1818 silver badges1515 bronze badges
Comments

3

I had faced a similar problem. I was unable to use the basic Spring Security authentication with NGINX. Apart from setting the proxy_pass_header X-XSRF-TOKEN;, I also had to set underscores_in_headers on;, since NGINX by default does not allow headers with underscores and the CSRF token is named \_csrf.

So my final configuration file looked like this:

server {
underscores_in_headers on;
listen 80 default_server;
listen [::]:80 default_server ipv6only=on;

    root /usr/share/nginx/html;
    index index.html index.htm;

    # Make site accessible from http://localhost/
    server_name localhost;

    location / {
            # First attempt to serve request as file, then
            # as directory, then fall back to displaying a 404.
            try_files $uri $uri/ =404;
            # Uncomment to enable naxsi on this location
            # include /etc/nginx/naxsi.rules
    }
    location /example/ {
            proxy_pass_header X-XSRF-TOKEN;
            proxy_pass      http://localhost:8080/;
    }

}
Share
Improve this answer
Follow
answered Jun 22, 2016 at 5:33
Akshay's user avatar
Akshay
10911 silver badge77 bronze badges
Comments

3

I solved this problem without CSRF header in NGINX proxy.

My stack: spring-boot, spring-security (with redis session store), spring-boot-websocket with default STOMP implementation, NGINX to serve frontend and proxied to another services that frontend consume.

In first time I use the default configuration show in the NGINX Blog here and here (copy and paste for history):

http {
map $http_upgrade $connection_upgrade {
default upgrade;
'' close;
}

    upstream websocket {
        server 192.168.100.10:8010;
    }

    server {
        listen 8020;
        location / {
            proxy_pass http://websocket;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }

}
But dont work, still 403 Forbidden.

I fixed this issue with the configuration below (the real important part to fix websocket is # WebSocket Proxy):

worker_processes 1;

events {
worker_connections 1024;
}

http {

    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       30010;
        server_name  localhost;
        client_max_body_size 10M;

        location / {
            root   /usr/share/nginx/html;
            index  index.html index.htm;
        }

        # Backend API Proxy
        location /api {
            proxy_pass http://192.168.0.100:30080;
            proxy_set_header Host $http_host;
            proxy_set_header Access-Control-Allow-Origin 192.168.0.100;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-NginX-Proxy true;
            rewrite ^/api/?(.*) /$1 break;
            proxy_redirect off;
        }

        # CDN Proxy
        location ~ ^/cdn/(.*) {
            proxy_pass http://192.168.0.110:9000;
            rewrite ^/cdn/(.*) /$1 break;
        }

        # This is the configuration that fix the problem with WebSocket
        # WebSocket Proxy
        location /ws {
            proxy_pass http://192.168.0.120:30090;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $http_host;
            proxy_set_header Access-Control-Allow-Origin 192.168.0.120;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-NginX-Proxy true;
        }

    }

}
Share
Improve this answer
Follow
answered Jun 28, 2017 at 17:49
Marco Blos's user avatar
Marco Blos
1,0561111 silver badges2626 bronze badges
Comments

0

In my case (Spring Boot app), in addition to setting the Origin header as specified in the accepted answer, I had to set the Host header to match the ip:port of the Origin header, or to get rid of it altogether.

This is my working vhost config:

server {
listen 443 ssl;
listen [::]:443 ssl;

        ssl_certificate /etc/ssl/certs/<your-cert-file>.pem;
        ssl_certificate_key /etc/ssl/private/<your-key-file>.key;

        server_name <your-server-fqdn>;

        access_log /var/log/nginx/<your-server-fqdn>.access.log;
        error_log /var/log/nginx/<your-server-fqdn>.error.log error;

        root /srv/www/<your-server-fqdn>;
        index index.html index.html;

        location / {
                try_files $uri $uri/ /index.html;
        }

        location /api {
                proxy_pass http://127.0.0.1:8080/v1;
        }

        location /async-api {
                proxy_pass http://127.0.0.1:8080/stomp;

                proxy_http_version 1.1;

                # either set Host header as follows or get rid of the directive altogether
                #proxy_set_header Host "127.0.0.1:8080";

                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";

                # Set origin to the real instance, otherwise a of Spring security check will fail
                # Same value as defined in proxy_pass
                proxy_set_header Origin "http://127.0.0.1:8080";

                proxy_set_header X-Forwarded-Host $host:$server_port;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location /admin-api {
                proxy_pass http://127.0.0.1:8080/api;
        }

}

---

KONG gateway api testing failing using jmeter
Asked 7 years, 3 months ago
Modified 7 years, 3 months ago
Viewed 1k times
0

Sample Imagedefined api and path am currently testing KONG gateway api load testing using jmeter

Am getting 403 error.

Please suggest me how can I resolve this issue thanks in advance.

Sample Image

Sample Image

jmeterhttp-status-code-403
Share
Improve this question
Follow
edited Jul 26, 2018 at 11:53
Raedwald's user avatar
Raedwald
49.2k4949 gold badges162162 silver badges250250 bronze badges
asked Jul 25, 2018 at 4:56
swarna's user avatar
swarna
133 bronze badges
Add a comment
1 Answer
Sorted by:

Highest score (default)
0

HTTP Status Code 403 means Forbidden so either your apikey parameter is not correct or you're passing it in a wrong way.

Also I have a doubt regarding your URL, if your endpoint is protected with Basic HTTP Authentication you either need:

To add your password to the URL like:

ec2user:your_password@ec2-52-70-117-82.....
Or to remove this ec2user@ from the hostname field and provide it along with the password via HTTP Authorization Manager
Share
Improve this answer

---

ACL + key-auth plugin on a Kong service not working
Asked 2 years, 3 months ago
Modified 2 years, 3 months ago
Viewed 3k times
0

I'm using Kong Gateway (community edition, using database, dockerized setup, kong:3.3.0) and Konga + King + manual apis to manage it.

I have a key-auth plugin setup on a service in Kong, and when I hit the route under it with a consumer's valid apikey included in the url parameters, it's working fine, exactly as described.

Now I want to restrict access based on groups of consumers. The path given to achieve this is: add ACL plugin for this service, giving the group name in Allow. Done. ACL plugin konga

This group shows up properly in King's view of the plugin as well: ACL plugin King

Next, for the consumer who should be able to access this: Add it to an ACL group by the same name: Done. Consumer ACL King

But once this is all setup, I'm no longer able to access the route. Getting 403 response with message: "You cannot consume this service"

If I disable the ACL plugin, it works again. (with the consumer's apikey included in the url parameters - key-auth plugin alone is working)

I'm not understanding what's going wrong here. I saw guides showing a similar setup with JWT plugin : https://medium.com/engineering-applift/kong-acl-example-77a033d59034 and OAuth2: https://medium.com/@far3ns/kong-acl-plugin-76a9ff948f4c . At first I thought a precise id value of the ACL group will be needed, but from all the documentation it seems just setting the group name at both consumer side and plugin side should do the job. But it's not happening. Can someone help to solve this?

Ref: https://docs.konghq.com/hub/kong-inc/acl/how-to/basic-example/

Edit: updated the version in top, 3.3.0

Edit: Clarification: There are other services/routes active in my setup which are open and don't have a key-auth plugin on them. Hence, I'm enabling the key-auth plugin for few services (hence, at service-level not global), upon which then I want to enable ACL plugin.

kongkong-pluginkonga
Share
Improve this question
Follow
edited Jul 12, 2023 at 16:39
asked Jul 10, 2023 at 10:21
Nikhil VJ's user avatar
Nikhil VJ
6,24277 gold badges3838 silver badges6262 bronze badges
What's the Kong version? Based on your explanation It should work. Can you post a decK dump result to the question? â€“
Ponsakorn30214
CommentedJul 10, 2023 at 14:53
@Ponsakorn30214 version is 3.3.0. And I'm not able to get the deck dump command for a docker compose deployment. keep getting no configuration file provided: not found for docker compose exec kong-gateway kong deck dump â€“
Nikhil VJ
CommentedJul 12, 2023 at 16:31
maybe install decK on the host machine and point it to Admin API on the container. decK is provided as a binary so you should be able to use it without installing much. â€“
Ponsakorn30214
CommentedJul 13, 2023 at 7:30
Add a comment
1 Answer
Sorted by:

Highest score (default)
2

I am unsure I saw all the required bits in your question -- in particular, I am afraid the ACL plugin does not find an authenticated consumer -- but here goes a working example using the Admin API, hopefully it helps!

Create a service / route pair:
$ http :8001/services url=http://mockbin.org name=mockbin -f
$ http :8001/services/mockbin/routes paths=/ -f

# issue a test request to the /request endpoint, useful for debugging headers that got sent to the upstream

$ http :8000/request
Create a consumer and map it to the ACL group:
$ http :8001/consumers username=c1 -f
$ http :8001/consumers/c1/acls group=g1 -f
Create keyauth token and enable keyauth plugin
$ http :8001/consumers/c1/key-auth key=token
$ http :8001/plugins name=key-auth
$ http :8001/plugins name=acl config.allow=g1 -f
Issue another testing request:
$ http :8000/request apikey:token

# See how the x-consumer-group header was sent upstream

$ http :8000/request apikey:token | jq '.headers["x-consumer-groups"]'
Note that the apikey is required so that Kong can map it to a consumer, from which it can verify against the ACL plugin's config -- allow or disallow.

---

Get started with Konnect
Docs
Kong Community
Error to connect websocket Kong Kubernetes
Questions
kubernetes
Jun 2022
Jun 2022

Tiago_Miranda

1
Jun 2022
Hi all,
I am using kong and kubernetes and connect websocket outside cluster doesâ€™nt works.
I have problem to connect websocket: Socket.js:65 WebSocket connection to â€˜wss://kstaging.admooh.com/companion/api/4259514d-5b53-4aa3-95c6-6a17f817dbdcâ€™ failed:

I got connect directly in kubernetes service without use kong.

Kubernetes service yaml:

apiVersion: v1
kind: Service
metadata:
name: companion-service
namespace: services
spec:
ports: - port: 443
protocol: TCP
targetPort: 3020
selector:
app.kubernetes.io/instance: companion
app.kubernetes.io/name: companion
Kubernetes ingress:

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
annotations:
konghq.com/protocols: 'https'
konghq.com/strip-path: 'false'
kubernetes.io/ingress.class: kong
name: companion-service
namespace: services
spec:
rules: - host: kstaging.admooh.com
http:
paths: - backend:
service:
name: companion-service
port:
number: 443
path: /companion
pathType: ImplementationSpecific
Somebody can help me to configure kong in kubernetes to work websockets?

1.2k
views

traines
Jun 2022
Does it work if you send that request through the Kong proxy service inside the cluster? Normally nothing special is needed to handle WSS in the proxy configuration; itâ€™s just like any other HTTPS route.

If it does work internally, is there an HTTP/L7 load balancer in front of the proxy service for external inbound traffic? That could interfere depending on what it supports and how itâ€™s configured, so we usually recommend using a TCP/L4 load balancer (e.g. an NLB instead of an ALB).

---

Websocket connection Key auth plugin #7122
Closed
Closed
Websocket connection Key auth plugin
#7122
@priyankaraghavan
Description
priyankaraghavan
opened on May 6, 2021
Hi- I would like to validate clients with websocket connection on my kong gateway. The way I do it is with Key auth plugin. Now i find the key auth plugin with websocket connections do not work. Is this not supported. What is good way of adding authentication for websocket protocol?

Activity
bungle
bungle commented on May 6, 2021
bungle
on May 6, 2021
Member
@priyankaraghavan, can you tell us a bit how it does not work.

bungle
added
core/proxy

plugins/key-auth

pending author feedback
Waiting for the issue author to get back to a maintainer with findings, more details, etc...
on May 6, 2021
stale
stale commented on May 27, 2021
stale
bot
on May 27, 2021
This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.

stale
added
stale
on May 27, 2021
priyankaraghavan
priyankaraghavan commented on May 27, 2021
priyankaraghavan
on May 27, 2021
Author
Hi @bungle i am currently doing it as a query parameter. When i tried to examine the wss via a network interceptor i could not see it. I did this with wireshark. Therefore for now all WSS connections pass api key for key auth with query param

kikito
removed
pending author feedback
Waiting for the issue author to get back to a maintainer with findings, more details, etc...
on May 31, 2021

stale
removed
stale
on May 31, 2021
kikito
kikito commented on Jan 18, 2023
kikito
on Jan 18, 2023
Member
Hello @priyankaraghavan , the open source version of Kong does not support websockets, that is an EE-only feature.

If you are using Kong Enterprise Edition and you are still having this issue, I suggest you contact your Sales Representative, in order to have this properly prioritized.

---

Realtime API management with Pushpin and Kong
Jul 14, 2015 â€¢ posted by justin â€¢ filed under api, grip, pushpin, websockets

Pushpin is the open source reverse proxy for the realtime web. One of the benefits of Pushpin functioning as a proxy is that it can be combined with an API management system, such as Mashapeâ€™s Kong. Kong is the open source management layer for APIs. To use Kong with Pushpin, simply chain the two together on the same network path.

pushpin-kong

Why would you want to use an API management system with Pushpin? Realtime web services have many of the same concerns as request/response web services, and it can be helpful to centrally manage those aspects.

For example, Kong enables centralized management of concerns such as:

Authentication
Logging/analytics
Traffic manipulation
See Kongâ€™s plugin page for a full list of features.

Proxy order
Since both Pushpin and Kong are reverse proxies, you may wonder what order they should be placed. As it turns out, both ways work, with different trade-offs.

If Pushpin is placed in front of Kong:

Kong is able to inspect/manipulate any instructions the backend sends to Pushpin.
Pushpin can convert WebSocket connections into a series of HTTP requests, allowing Kong to manage a WebSocket API.
Kong is unable to see data published through Pushpin.
If Kong is placed in front of Pushpin:

Kong sees data published through Pushpin.
WebSockets wonâ€™t work.
Kong logging of HTTP streaming will delay until connection closes.
If youâ€™re using the Fanout Cloud version of Pushpin, then you donâ€™t have much choice; itâ€™ll always come first. Fortunately, this is arguably the preferred order. However, if you are running Pushpin and Kong on your own servers, then you can choose either order.

Authentication
API consumer authentication is one of the most valuable features of Kong. It can be used to provide protection to an API without having to implement authentication in the backend.

Suppose we have an HTTP streaming endpoint with the following architecture:

Pushpin listening on port 80, forwarding requests to localhost port 8000 (Kong).
Kong listening on port 8000, forwarding requests for api.example.com to port 9000 (internal API backend).
API backend listening on port 9000, serving a Pushpin-based HTTP streaming endpoint â€œ/events/â€, with no built-in authentication.
Kong also listening on port 8001, to handle internal management API calls.
With this architecture in place, a client is able to make a request to http://api.example.com/events/ and establish a long-lived HTTP streaming response:

$ curl -i http://api.example.com/events/

HTTP/1.1 200 OK
Via: kong/0.3.2
Content-Type: text/plain
Transfer-Encoding: chunked
Connection: Transfer-Encoding

{ ... event ... }
{ ... event ... }
...
We can then protect this API using Kongâ€™s keyauth plugin. Below is a sequence diagram of how the network flow will work:

pushpin-kong-auth

To set up Kong authentication, the first thing we do is add the keyauth plugin to the configured API:

$ curl -i -d name=keyauth -d value.key_names=Auth-Key \
 http://localhost:8001/apis/{api-id}/plugins
What this will do is block all requests to the API that do not provide a valid Auth-Key header. For example, hereâ€™s what happens if we access the API right now without a key:

$ curl -i http://api.example.com/events/

HTTP/1.1 403 Forbidden
Content-Type: application/json; charset=utf-8
Server: kong/0.3.2
Content-Length: 49

{"message":"Invalid authentication credentials"}
Next weâ€™ll create a consumer object and API key within Kong to be used for authentication. First we create the consumer:

$ curl -d username=alice http://localhost:8001/consumers/
Then we create an API key for that consumer:

$ curl -d key=supersecret \
 http://localhost:8001/consumers/{consumer-id}/keyauth
Now the streaming endpoint becomes accessible again using the API key:

$ curl -i -H "Auth-Key: supersecret" http://api.example.com/events/

HTTP/1.1 200 OK
Via: kong/0.3.2
Content-Type: text/plain
Transfer-Encoding: chunked
Connection: Transfer-Encoding

{ ... event ... }
{ ... event ... }
...
Adding authentication to a realtime API doesnâ€™t get easier than this!

WebSockets
Pushpin is able to convert WebSocket connections into a series of HTTP requests. This allows backend services (e.g. a service built with django-grip) to drive WebSocket connections without needing direct support for WebSockets. With this mode enabled, Kong is able to proxy the converted HTTP traffic between Pushpin and the backend.

This means you can use Kong to protect a WebSocket API the same way you would a normal HTTP API. Below is another sequence diagram, this time for a network flow involving WebSockets:

pushpin-kong-auth-ws

Suppose you have a WebSocket API living at ws://api.example.com/events/ that you can normally access like this:

$ wscat -c ws://api.example.com/events/
connected (press CTRL+C to quit)
If the keyauth Kong plugin is enabled, then accessing this API will require a key. For example, hereâ€™s a connection attempt made without a key:

$ wscat -c ws://api.example.com/events/
error: Error: unexpected server response (403)
As you can see, a 403 error is received, just like with HTTP. Access will only be granted if a valid key is provided:

$ wscat -H "Auth-Key: supersecret" -c ws://api.example.com/events/
connected (press CTRL+C to quit)
Additionally, WebSocket events will show up in Kongâ€™s logs as HTTP requests, which can be used for traffic analysis.

Logging
Logging is another useful function of Kong. It can be used to track traffic for analytics or billing purposes. To enable logging to a remote TCP server, add the tcplog plugin like this:

$ curl -i -d name=tcplog -d value.host=localhost -d value.port=9999 \
 http://localhost:8001/apis/{api-id}/plugins
With the tcplog plugin added to the API, any requests, including those that become HTTP streaming connections or get converted into WebSocket events, will be logged along with information about the authenticated consumer.

Conclusion
All APIs can benefit from API management, realtime or not. Pushpin makes it easy to create realtime APIs that can be managed by API management systems. If you are designing or building a realtime API infrastructure, definitely check out Pushpin and Kong. They are a great pair.

---

Connect to websocket under cloudflare causes 403 forbidden error #1925
Closed
Closed
Connect to websocket under cloudflare causes 403 forbidden error
#1925
@car1ot
Description
car1ot
opened on Aug 1, 2021 Â· edited by car1ot

I've searched for any related issues and avoided creating a duplicate
issue.
Description
I am trying to connect to websocket under cloudflare, and it refuse connection with 403 forbidden error.

When I am trying this in node.js, connection refused with 403 code.

new WebSocket('wss://live-arena-rjsqbe.agar.io/?party_id=GPUBAM', [], {
headers: {
Accept: `*/*`,
"Accept-Encoding": `gzip, deflate, br`,
"Accept-Language": `en-GB,en;q=0.5`,
"Cache-Control": `no-cache`,
Connection: `keep-alive, Upgrade`,
... More headers here ...
},
})
"websocket": "^1.0.34",
"ws": "^7.1.2",
"wss": "^3.3.4"
When I am trying to connect to websocket in this way from browser, it works fine.

Activity
lpinca
lpinca commented on Aug 1, 2021
lpinca
on Aug 1, 2021
Member
This is not a ws issue. The server is responding with 403 which means that access is forbidden. You probably need to add a Cookie or Authorization header. See what headers are sent in the browser. Also make sure you are actually using ws. websocket and ws are two different modules.

car1ot
car1ot commented on Aug 1, 2021
car1ot
on Aug 1, 2021
Author
This is not a ws issue. The server is responding with 403 which means that access is forbidden. You probably need to add a Cookie or Authorization header. See what headers are sent in the browser. Also make sure you are actually using ws. websocket and ws are two different modules.

I am using all required headers, wich are sent by browser. Also, I am using correct package. Problem is still the same.

lpinca
lpinca commented on Aug 2, 2021
lpinca
on Aug 2, 2021
Member
Did you also add the same User-Agent header? I'm sorry but I can't help you without a reproducible example and I can't establish a WebSocket connection to wss://live-arena-rjsqbe.agar.io/?party_id=GPUBAM from a browser.

car1ot
car1ot commented on Aug 2, 2021
car1ot
on Aug 2, 2021 Â· edited by car1ot
Author
Did you also add the same User-Agent header? I'm sorry but I can't help you without a reproducible example and I can't establish a WebSocket connection to wss://live-arena-rjsqbe.agar.io/?party_id=GPUBAM from a browser.

You need to enstablish connection from domain https://agar.io . Maybe some errors with Origin header? Exactly, I am using the same User-Agent. Also, I am passing "Origin": "https://agar.io", as it is in agar.io headers.

lpinca
lpinca commented on Aug 2, 2021
lpinca
on Aug 2, 2021
Member
The WebSocket constructor only works on ws: and wss: URLs . Please write the URL where the WebSocket connection is established is the browser.

car1ot
car1ot commented on Aug 2, 2021
car1ot
on Aug 2, 2021
Author
The WebSocket constructor only works on ws: and wss: URLs . Please write the URL where the WebSocket connection is established is the browser.

I am using wss: exactly. What is the problem?

lpinca
lpinca commented on Aug 2, 2021
lpinca
on Aug 2, 2021 Â· edited by lpinca
Member
Please write the URL where the WebSocket connection is established in the browser.

car1ot
car1ot commented on Aug 2, 2021
car1ot
on Aug 2, 2021 Â· edited by car1ot
Author
Please write the URL where the WebSocket connection is established in the browser.

agar.io may close servers after some time.
The fresh link (if it will work when you try) wss://live-arena-12cowy4.agar.io/?party_id=4DA458

If link don't work, try to catch the link in the browser inspector > network > websocket connection, when loading agar.io main page.
And try to make new WebSocket(url) with this link from browser, and after from node.js with same headers, as was in browser.
The browser connection works, but from node.js appears 403 error.

trasherdk
trasherdk commented on Aug 2, 2021
trasherdk
on Aug 2, 2021
Opening agar.io in Firefox makes all warning-lights go to red. Ad blockers and tracking blockers are working overtime ðŸ˜†

lpinca
lpinca commented on Aug 2, 2021
lpinca
on Aug 2, 2021
Member
@car1ot I don't know, I guess cloudflare uses some trick to detect browser usage. Anyway I also get 403 with https://github.com/vi/websocat so it's not a ws issue. I'm closing this. Discussion can continue if needed.

lpinca
closed this as completedon Aug 2, 2021
philhk
philhk commented on Oct 30, 2021
philhk
on Oct 30, 2021
I know this Issue isn't related to ws at all, but I ran into the same error but can't find anything on the Internet about it. @car1ot did you ever fixed this issue?

lpinca
lpinca commented on Oct 30, 2021
lpinca
on Oct 30, 2021 Â· edited by lpinca
Member
@felixvonderladen they probably use client fingerprinting. See https://www.cloudflare.com/products/bot-management/ and https://research.google/pubs/pub45581/.

philhk
philhk commented on Oct 31, 2021
philhk
on Oct 31, 2021
I'm not really sure if they do. What I tested was making a WebSocket connection on the same website, and It worked just fine. Then I tried it on Postman and changed most of the headers to match the connection on the website. It connected, but It gave me a 403 error. I don't know if the problem is from Postman, so I tried it in JavaScript with ws, but I couldn't change the origin. And now I'm stuck at this point. Is there someway to change the origin of the WebSocket in ws?

lpinca
lpinca commented on Oct 31, 2021
lpinca
on Oct 31, 2021 Â· edited by lpinca
Member
You can use any headers you want with the headers option as show in the issue description.

flaviut
flaviut commented on Feb 21, 2022
flaviut
on Feb 21, 2022
Looks like Cloudflare uses SSL client fingerprinting to do this blocking.

That pretty much means your options are:

figure out how to reproduce a fingerprint that cloudflare allows through (good luck!)
use a different way of connecting to your websocket (not this library or any other NodeJS thing)
contact Cloudflare/your site admin to add this client to the allowed list
Sorry to keep going off-topic, but hopefully this is a definitive answer to this problem.

lpinca
lpinca commented on Feb 21, 2022
lpinca
on Feb 21, 2022
Member
You can try to shuffle the default ciphers. See https://httptoolkit.tech/blog/tls-fingerprinting-node-js/.

iocmet
iocmet commented on Jun 28, 2022
iocmet
on Jun 28, 2022
How to fix it? I have same problem and I'm also trying to connect to wss://live-arena-XXXXXX.agar.io:443...

JhonatanRian
JhonatanRian commented on Mar 25, 2024
JhonatanRian
on Mar 25, 2024
Has anyone found a solution to this problem? I have the same problem but for another websocket.

myweorld
myweorld commented on Apr 22, 2024
myweorld
on Apr 22, 2024
same problem, any solve?

---

403 forbidden using websockets with spring boot
Asked 8 months ago
Modified 3 months ago
Viewed 150 times
0

I have spring security with JWT implemented in my application and was trying to set up the WebSocket connection. Initially I was sending the token in the headers of the WebSocket connection with the stomp client, however I realized that spring security seems to handle authentication differently compared to HTTP requests.I then tried to test to see if I was able to get a connection up and running as I set permit All on the WebSocket connection endpoint in the filter chain, having done this I still get a 403 forbidden error. Currently if my spring security filter chain permits the handshake connection the connection should be successful considering I already set up spring security CORS configuration to accept my client as the origin. If I were to ensure WebSocket connections are permitted to users but the sending of messages requires authentication, would it mean I need to implement a custom message interceptor to validate my token for each message or can i just extend the AbstractSecurity WebSocketMessageBroker Configurer and ensure all endpoints with /app\*\* are authenticated.

How would I authenticate subsequent requests under the STOMP protocol? Considering the Initial WebSocket connection is sent with under a HTTP protocol, even if I was to include the Authorization header then shouldn't it automatically be used by my JWT filter?

from the little documentation out there, what I've gathered is that if you include the token during the WebSocket handshake then because its under a HTTP protocol, your server will be able to validate the token. This would then set up the principal such that you can now set up subsequent messages to be authenticated by implementing the configureInbound method. However if I permit the handshake to not require authentication then I would need to implement a custom message interceptor that extracts the token from the send function on the the client side. something like

this.stompClient.send("/app/chat/send", {"Authorization" : "Bearer " + this.token}, JSON.stringify(message))

Below is all the code

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

     /// this method initiates the web socket connection, when a client wants to upgrade their
    /// protocol from HTTP to WebSocket
        /// . we also define the servers that can make initiate a websocket connection
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {

        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("http://localhost:49322")
                .withSockJS();
    }

    /// we define the prefix of the placeholder in the url as 'app' in which this will be binded to the
    /// MessageMapping annotation methods, similar to how requestMapping routed the endpoint to the specific method
    /// the message broker is used to define the endpoint in which a user will be subscribed to
    /// we set the user as the prefix
    ///
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/user");
        registry.setApplicationDestinationPrefixes("/app");
    }

}

package com.example.Dormly.websocket;

import lombok.RequiredArgsConstructor;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;

@org.springframework.stereotype.Controller
@RequiredArgsConstructor
public class Controller {

    private final SimpMessagingTemplate simpMessagingTemplate;
    ///
    /// The @MessageMapping is used to route all /app/placeholder destinations to their specific methods
    /// we use the principal to define the user who is the sender, and via a UI action
    /// we also include recipient to define who the end user is
    /// we create an output message object which contains a sender and the content
    /// we then send this output message to the user
    /// The message object just has the recipient(to whom we send to) and the content, the sender is fetched from the principal
    @MessageMapping("/chat/send")
    public void sendMessage(@Payload  Message message , @AuthenticationPrincipal UserDetails user){
        OutputMessage outputMessage = new OutputMessage(
                message.getContent(),
                user.getUsername() /// user who sent the message - the recipient will see this
        );
        /// the server will send back something like '/user/james/queue/chat'
        simpMessagingTemplate.convertAndSendToUser(message.getRecipient(),"/queue/chat", outputMessage);


    }

}

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final AuthenticationProvider authenticationProvider;
    private final JwtAuthFilter jwtAuthFilter;


    /**
     * Configuration annotation tells spring that there is more than one bean that needs to be instantiated as a singleton
     * SecurityFilterChain applies a set of filters to our HTTP requests.
     */

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.
        cors(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(http->http.
                        requestMatchers("/api/v1/Sign-up").permitAll()
                        .requestMatchers("/api/v1/login").permitAll()
                        .requestMatchers("/ws**").permitAll()
                        .anyRequest()
                        .authenticated()
                )
        /**
         * ensure our session management remains stateless, as we authenticate once per request
         */

                        .sessionManagement(session-> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)

                )
                /**
                 * when spring security intercepts the login request, the usernamepasswordfilter delegates
                 * this to the auth manager in which that uses the provider manager impl to find the auth provider.
                 * The auth provider is called to validate the credentials as it receives an auth object
                 * Also ensure the jwt filter gets called before the usernamepass filter
                 * as we always need to check if a JWT is present, if not the request is passed to other filters
                 * This way we handle requests for unauthenticated and authenticated users
                 * not authenticated(meaning no jwt) -> UsernamePassFilter gets used
                 * authenticated(has Jwt) -> jwtAuthFilter
                 */

                .authenticationProvider(authenticationProvider)
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

                return httpSecurity.build();


    }

import { Injectable } from '@angular/core';
import { TokenService } from '../auth/token/token.service';
import SockJS from 'sockjs-client';
import { Stomp } from '@stomp/stompjs';
import { Message } from '../models/Message';
import { MessagesComponent } from '../messages/messages.component';
import { BehaviorSubject } from 'rxjs';

@Injectable({
providedIn: 'root'
})
export class WebSocketApiService {
//create a subject to communicate the responses back to the messages component
private subject = new BehaviorSubject(null)
messageSubscription$ = this.subject.asObservable()

destination:string = "/user/queue/chat"
brokerURL:string = "http://localhost:8099/ws"
stompClient:any
token!:string

constructor(private tokenService:TokenService) {
this.token = this.tokenService.token as string
}
connect(){
console.log("connecting to websocket...")
const headers = { "Authorization": "Bearer " + this.token };
console.log("WebSocket headers:", headers); // Log the headers

    let ws = new SockJS(this.brokerURL)
    this.stompClient = Stomp.over(ws)
    this.stompClient.connect({"Authorization" : `Bearer ${this.token}`}, () =>{
      console.log("WebSocket connected");

        ///the stompclient takes 3 parameters which includes the headers and 2 callback functions,
        ///the frames defined the handshake agreement of protocol switches, and once the event occurs we can now subscribe to the destination

        this.stompClient.subscribe(this.destination, (message:any)=>{
          //the subscribe also triggers a callback which means when a user subscribes to a destination, an event of a message could be returned
          this.onMessageRecieved(message)

        })

    },
    ///error callback
    (error:Error | any)=>{
    this.errorCallBack(error)
    }

)

}
errorCallBack(error:Error):void{
console.log(error.message)

}

disconnect(){
if(this.stompClient!==null){
this.stompClient.disconnect()
console.log("disconnected")
}
setTimeout(()=>{
this.connect()
}, 5000) //reconnect after 5 seconds

}

onMessageRecieved(message:any) {
if(message){
///manual deserialization with websockets. using Json.parse() to convert the json into a javascript objecy
console.log("message recieved ", message)
this.subject.next(JSON.parse(message))
console.log("added message to the subject")
}

}

send(message:Message):void{
///when the user sends a message, our in memory message broker in spring will automatically forward it to the destination the user is subscribed to
///the user will recieve the message immediatley assuming the connection is still live - if not we persist the chat to the db
///all messages are sent with the /app prefix and users are able to send messages
///the message object includes the recieptent and the message itself.
///websocket does not serialize the object into a json like HTTP does, hence we do it manually
this.stompClient.send("/app/chat/send", {"Authorization" : "Bearer " + this.token}, JSON.stringify(message))
}

}
This is what shows up in the console in order

[Log] calling service class to connect to websocket (main.js, line 2372)

[Log] connecting to websocket... (main.js, line 2275) [Warning] Stomp.over did not receive a factory, auto reconnect will not work. Please see https://stomp-js.github.io/api- docs/latest/classes/Stomp.html#over (@stomp_stompjs.js, line 1534)

[Log] Opening Web Socket... (@stomp_stompjs.js, line 1286) [Debug] [vite] connected. (client, line 859)

[Error] Failed to load resource: the server responded with a status of 403 () (info, line 0)

[Log] Connection closed to http://localhost:8099/ws (@stomp_stompjs.js, line 1286)

javaangularspringspring-bootwebsocket
Share
Improve this question
Follow
edited Feb 24 at 22:54
asked Feb 24 at 22:38
Abas jama's user avatar
Abas jama
922 silver badges22 bronze badges
Add a comment
1 Answer
Sorted by:

Highest score (default)
0

WebSocket security with JWT can be a little tricky!!

The main issue is that Spring Security does not view a WebSocket connection as a standard HTTP request, and so even if you send the token as you normally would in the headers of the handshake, the normal JWT filter will not grab it.

The typical thing that people do is allow the initial connection (i.e., there's no authentication on the /ws) and then review and check the token every time there is a message using a ChannelInterceptor.

This will allow you to access the @AuthenticationPrincipal in your @MessageMapping methods to identify the user. Just keep in mind to send the token in headers for the connect() and the send().

While you'll be relying on the client to send updates about the token on each message, it is still secure since it has to be sent again each time.
