# Crate row Copy item path

<a href="https://docs.rs/arrow-row/56.0.0/x86_64-unknown-linux-gnu/src/arrow_row/lib.rs.html#18-3304" class="src">Source</a>

Expand description

A comparable row-oriented representation of a collection of [`Array`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/array/trait.Array.html "trait datafusion::common::arrow::array::Array").

[`Row`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Row.html "struct datafusion::common::arrow::row::Row")s are [normalized for sorting](http://wwwlgis.informatik.uni-kl.de/archiv/wwwdvs.informatik.uni-kl.de/courses/DBSREAL/SS2005/Vorlesungsunterlagen/Implementing_Sorting.pdf), and can therefore be very efficiently [compared](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html "trait core::cmp::PartialOrd"), using [`memcmp`](https://www.man7.org/linux/man-pages/man3/memcmp.3.html) under the hood, or used in [non-comparison sorts](https://en.wikipedia.org/wiki/Sorting_algorithm#Non-comparison_sorts) such as [radix sort](https://en.wikipedia.org/wiki/Radix_sort). This makes the row format ideal for implementing efficient multi-column sorting, grouping, aggregation, windowing and more, as described in more detail [in this blog post](https://arrow.apache.org/blog/2022/11/07/multi-column-sorts-in-arrow-rust-part-1/).

For example, given three input [`Array`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/array/trait.Array.html "trait datafusion::common::arrow::array::Array"), [`RowConverter`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowConverter.html "struct datafusion::common::arrow::row::RowConverter") creates byte sequences that [compare](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html "trait core::cmp::PartialOrd") the same as when using [`lexsort`](https://docs.rs/arrow-ord/latest/arrow_ord/sort/fn.lexsort.html).

``` text
   ┌─────┐   ┌─────┐   ┌─────┐
   │     │   │     │   │     │
   ├─────┤ ┌ ┼─────┼ ─ ┼─────┼ ┐              ┏━━━━━━━━━━━━━┓
   │     │   │     │   │     │  ─────────────▶┃             ┃
   ├─────┤ └ ┼─────┼ ─ ┼─────┼ ┘              ┗━━━━━━━━━━━━━┛
   │     │   │     │   │     │
   └─────┘   └─────┘   └─────┘
               ...
   ┌─────┐ ┌ ┬─────┬ ─ ┬─────┬ ┐              ┏━━━━━━━━┓
   │     │   │     │   │     │  ─────────────▶┃        ┃
   └─────┘ └ ┴─────┴ ─ ┴─────┴ ┘              ┗━━━━━━━━┛
    UInt64      Utf8     F64

          Input Arrays                          Row Format
    (Columns)
```

*[`Rows`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Rows.html "struct datafusion::common::arrow::row::Rows") must be generated by the same [`RowConverter`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowConverter.html "struct datafusion::common::arrow::row::RowConverter") for the comparison to be meaningful.*

## <a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/index.html#basic-example" class="doc-anchor">§</a>Basic Example

``` rust

let a1 = Arc::new(Int32Array::from_iter_values([-1, -1, 0, 3, 3])) as ArrayRef;
let a2 = Arc::new(StringArray::from_iter_values(["a", "b", "c", "d", "d"])) as ArrayRef;
let arrays = vec![a1, a2];

// Convert arrays to rows
let converter = RowConverter::new(vec![
    SortField::new(DataType::Int32),
    SortField::new(DataType::Utf8),
]).unwrap();
let rows = converter.convert_columns(&arrays).unwrap();

// Compare rows
for i in 0..4 {
    assert!(rows.row(i) <= rows.row(i + 1));
}
assert_eq!(rows.row(3), rows.row(4));

// Convert rows back to arrays
let converted = converter.convert_rows(&rows).unwrap();
assert_eq!(arrays, converted);

// Compare rows from different arrays
let a1 = Arc::new(Int32Array::from_iter_values([3, 4])) as ArrayRef;
let a2 = Arc::new(StringArray::from_iter_values(["e", "f"])) as ArrayRef;
let arrays = vec![a1, a2];
let rows2 = converter.convert_columns(&arrays).unwrap();

assert!(rows.row(4) < rows2.row(0));
assert!(rows.row(4) < rows2.row(1));

// Convert selection of rows back to arrays
let selection = [rows.row(0), rows2.row(1), rows.row(2), rows2.row(0)];
let converted = converter.convert_rows(selection).unwrap();
let c1 = converted[0].as_primitive::<Int32Type>();
assert_eq!(c1.values(), &[-1, 4, 0, 3]);

let c2 = converted[1].as_string::<i32>();
let c2_values: Vec<_> = c2.iter().flatten().collect();
assert_eq!(&c2_values, &["a", "f", "c", "e"]);
```

## <a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/index.html#lexsort" class="doc-anchor">§</a>Lexsort

The row format can also be used to implement a fast multi-column / lexicographic sort

``` rust
fn lexsort_to_indices(arrays: &[ArrayRef]) -> UInt32Array {
    let fields = arrays
        .iter()
        .map(|a| SortField::new(a.data_type().clone()))
        .collect();
    let converter = RowConverter::new(fields).unwrap();
    let rows = converter.convert_columns(arrays).unwrap();
    let mut sort: Vec<_> = rows.iter().enumerate().collect();
    sort.sort_unstable_by(|(_, a), (_, b)| a.cmp(b));
    UInt32Array::from_iter_values(sort.iter().map(|(i, _)| *i as u32))
}
```

## Structs<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/index.html#structs" class="anchor">§</a>

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.OwnedRow.html" class="struct" title="struct datafusion::common::arrow::row::OwnedRow">OwnedRow</a>  
Owned version of a [`Row`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Row.html "struct datafusion::common::arrow::row::Row") that can be moved/cloned freely.

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Row.html" class="struct" title="struct datafusion::common::arrow::row::Row">Row</a>  
A comparable representation of a row.

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowConverter.html" class="struct" title="struct datafusion::common::arrow::row::RowConverter">RowConverter</a>  
Converts [`ArrayRef`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/array/type.ArrayRef.html "type datafusion::common::arrow::array::ArrayRef") columns into a [row-oriented](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/index.html "mod datafusion::common::arrow::row") format.

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowParser.html" class="struct" title="struct datafusion::common::arrow::row::RowParser">RowParser</a>  
A [`RowParser`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowParser.html "struct datafusion::common::arrow::row::RowParser") can be created from a [`RowConverter`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowConverter.html "struct datafusion::common::arrow::row::RowConverter") and used to parse bytes to [`Row`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Row.html "struct datafusion::common::arrow::row::Row")

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Rows.html" class="struct" title="struct datafusion::common::arrow::row::Rows">Rows</a>  
A row-oriented representation of arrow data, that is normalized for comparison.

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.RowsIter.html" class="struct" title="struct datafusion::common::arrow::row::RowsIter">RowsIter</a>  
An iterator over [`Rows`](https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.Rows.html "struct datafusion::common::arrow::row::Rows")

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/struct.SortField.html" class="struct" title="struct datafusion::common::arrow::row::SortField">SortField</a>  
Configure the data type and sort order for a given column

## Functions<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/index.html#functions" class="anchor">§</a>

<a href="https://docs.rs/datafusion/50.2.0/datafusion/common/arrow/row/fn.encode_dictionary_values.html" class="fn" title="fn datafusion::common::arrow::row::encode_dictionary_values">encode_dictionary_values</a>  
Encode dictionary values not preserving the dictionary encoding
