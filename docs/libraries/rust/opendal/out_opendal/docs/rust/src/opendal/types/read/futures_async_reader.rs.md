# 

opendal/types/read/

futures_async_reader.rs

``` rust
1// Licensed to the Apache Software Foundation (ASF) under one
2// or more contributor license agreements.  See the NOTICE file
3// distributed with this work for additional information
4// regarding copyright ownership.  The ASF licenses this file
5// to you under the Apache License, Version 2.0 (the
6// "License"); you may not use this file except in compliance
7// with the License.  You may obtain a copy of the License at
8//
9//   http://www.apache.org/licenses/LICENSE-2.0
10//
11// Unless required by applicable law or agreed to in writing,
12// software distributed under the License is distributed on an
13// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
14// KIND, either express or implied.  See the License for the
15// specific language governing permissions and limitations
16// under the License.
17
18use std::io;
19use std::io::SeekFrom;
20use std::ops::Range;
21use std::pin::Pin;
22use std::sync::Arc;
23use std::task::Context;
24use std::task::Poll;
25use std::task::ready;
26
27use bytes::Buf;
28use futures::AsyncBufRead;
29use futures::AsyncRead;
30use futures::AsyncSeek;
31use futures::StreamExt;
32
33use crate::raw::*;
34use crate::*;
35
36/// FuturesAsyncReader is the adapter of [`AsyncRead`], [`AsyncBufRead`]
37/// and [`AsyncSeek`] generated by [`Reader::into_futures_async_read`].
38///
39/// Users can use this adapter in cases where they need to use [`AsyncRead`]
40/// related trait. FuturesAsyncReader reuses the same concurrent and chunk
41/// settings from [`Reader`].
42///
43/// FuturesAsyncReader also implements [`Unpin`], [`Send`] and [`Sync`]
44pub struct FuturesAsyncReader {
45    ctx: Arc<ReadContext>,
46
47    stream: BufferStream,
48    buf: Buffer,
49    start: u64,
50    end: u64,
51    pos: u64,
52}
53
54/// Safety: FuturesAsyncReader only exposes `&mut self` to the outside world,
55unsafe impl Sync for FuturesAsyncReader {}
56
57impl FuturesAsyncReader {
58    /// NOTE: don't allow users to create FuturesAsyncReader directly.
59    ///
60    /// # TODO
61    ///
62    /// Extend this API to accept `impl RangeBounds`.
63    #[inline]
64    pub(super) fn new(ctx: Arc<ReadContext>, range: Range<u64>) -> Self {
65        let (start, end) = (range.start, range.end);
66        let stream = BufferStream::new(ctx.clone(), start, Some(end - start));
67
68        FuturesAsyncReader {
69            ctx,
70            stream,
71            buf: Buffer::new(),
72            start,
73            end,
74            pos: 0,
75        }
76    }
77}
78
79impl AsyncBufRead for FuturesAsyncReader {
80    fn poll_fill_buf(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<&[u8]>> {
81        let this = self.get_mut();
82        loop {
83            if this.buf.has_remaining() {
84                return Poll::Ready(Ok(this.buf.chunk()));
85            }
86
87            this.buf = match ready!(this.stream.poll_next_unpin(cx)) {
88                Some(Ok(buf)) => buf,
89                Some(Err(err)) => return Poll::Ready(Err(format_std_io_error(err))),
90                None => return Poll::Ready(Ok(&[])),
91            };
92        }
93    }
94
95    fn consume(mut self: Pin<&mut Self>, amt: usize) {
96        self.buf.advance(amt);
97        // Make sure buf has been dropped before starting new request.
98        // Otherwise, we will hold those bytes in memory until next
99        // buffer reaching.
100        if self.buf.is_empty() {
101            self.buf = Buffer::new();
102        }
103        self.pos += amt as u64;
104    }
105}
106
107/// TODO: implement vectored read.
108impl AsyncRead for FuturesAsyncReader {
109    fn poll_read(
110        self: Pin<&mut Self>,
111        cx: &mut Context<'_>,
112        buf: &mut [u8],
113    ) -> Poll<io::Result<usize>> {
114        let this = self.get_mut();
115
116        loop {
117            if this.buf.remaining() > 0 {
118                let size = this.buf.remaining().min(buf.len());
119                this.buf.copy_to_slice(&mut buf[..size]);
120                this.pos += size as u64;
121                return Poll::Ready(Ok(size));
122            }
123
124            this.buf = match ready!(this.stream.poll_next_unpin(cx)) {
125                Some(Ok(buf)) => buf,
126                Some(Err(err)) => return Poll::Ready(Err(format_std_io_error(err))),
127                None => return Poll::Ready(Ok(0)),
128            };
129        }
130    }
131}
132
133impl AsyncSeek for FuturesAsyncReader {
134    fn poll_seek(
135        mut self: Pin<&mut Self>,
136        _: &mut Context<'_>,
137        pos: SeekFrom,
138    ) -> Poll<io::Result<u64>> {
139        let new_pos = match pos {
140            SeekFrom::Start(pos) => pos as i64,
141            SeekFrom::End(pos) => self.end as i64 - self.start as i64 + pos,
142            SeekFrom::Current(pos) => self.pos as i64 + pos,
143        };
144
145        // Check if new_pos is negative.
146        if new_pos < 0 {
147            return Poll::Ready(Err(io::Error::new(
148                io::ErrorKind::InvalidInput,
149                "invalid seek to a negative position",
150            )));
151        }
152
153        let new_pos = new_pos as u64;
154
155        if (self.pos..self.pos + self.buf.remaining() as u64).contains(&new_pos) {
156            let cnt = new_pos - self.pos;
157            self.buf.advance(cnt as _);
158        } else {
159            self.buf = Buffer::new();
160            self.stream = BufferStream::new(
161                self.ctx.clone(),
162                new_pos + self.start,
163                Some(self.end - self.start - new_pos),
164            );
165        }
166
167        self.pos = new_pos;
168        Poll::Ready(Ok(self.pos))
169    }
170}
171
172#[cfg(test)]
173mod tests {
174    use std::sync::Arc;
175
176    use bytes::Bytes;
177    use futures::AsyncBufReadExt;
178    use futures::AsyncReadExt;
179    use futures::AsyncSeekExt;
180    use pretty_assertions::assert_eq;
181
182    use super::*;
183
184    #[tokio::test]
185    async fn test_trait() -> Result<()> {
186        let acc = Operator::via_iter(Scheme::Memory, [])?.into_inner();
187        let ctx = Arc::new(ReadContext::new(
188            acc,
189            "test".to_string(),
190            OpRead::new(),
191            OpReader::new(),
192        ));
193
194        let v = FuturesAsyncReader::new(ctx, 4..8);
195
196        let _: Box<dyn Unpin + MaybeSend + Sync + 'static> = Box::new(v);
197        Ok(())
198    }
199
200    #[tokio::test]
201    async fn test_futures_async_read() -> Result<()> {
202        let op = Operator::via_iter(Scheme::Memory, [])?;
203        op.write(
204            "test",
205            Buffer::from(vec![Bytes::from("Hello"), Bytes::from("World")]),
206        )
207        .await?;
208
209        let acc = op.into_inner();
210        let ctx = Arc::new(ReadContext::new(
211            acc,
212            "test".to_string(),
213            OpRead::new(),
214            OpReader::new(),
215        ));
216
217        let mut fr = FuturesAsyncReader::new(ctx, 4..8);
218        let mut bs = vec![];
219        fr.read_to_end(&mut bs).await.unwrap();
220        assert_eq!(&bs, "oWor".as_bytes());
221
222        let pos = fr.seek(SeekFrom::Current(-2)).await.unwrap();
223        assert_eq!(pos, 2);
224        let mut bs = vec![];
225        fr.read_to_end(&mut bs).await.unwrap();
226        assert_eq!(&bs, "or".as_bytes());
227
228        Ok(())
229    }
230
231    #[tokio::test]
232    async fn test_futures_async_read_with_concurrent() -> Result<()> {
233        let op = Operator::via_iter(Scheme::Memory, [])?;
234        op.write(
235            "test",
236            Buffer::from(vec![Bytes::from("Hello"), Bytes::from("World")]),
237        )
238        .await?;
239
240        let acc = op.into_inner();
241        let ctx = Arc::new(ReadContext::new(
242            acc,
243            "test".to_string(),
244            OpRead::new(),
245            OpReader::new().with_concurrent(3).with_chunk(1),
246        ));
247
248        let mut fr = FuturesAsyncReader::new(ctx, 4..8);
249        let mut bs = vec![];
250        fr.read_to_end(&mut bs).await.unwrap();
251        assert_eq!(&bs, "oWor".as_bytes());
252
253        // let pos = fr.seek(SeekFrom::Current(-2)).await.unwrap();
254        // assert_eq!(pos, 2);
255        // let mut bs = vec![];
256        // fr.read_to_end(&mut bs).await.unwrap();
257        // assert_eq!(&bs, "or".as_bytes());
258
259        Ok(())
260    }
261
262    #[tokio::test]
263    async fn test_futures_async_buf_read() -> Result<()> {
264        let op = Operator::via_iter(Scheme::Memory, [])?;
265        op.write(
266            "test",
267            Buffer::from(vec![Bytes::from("Hello"), Bytes::from("World")]),
268        )
269        .await?;
270
271        let acc = op.into_inner();
272        let ctx = Arc::new(ReadContext::new(
273            acc,
274            "test".to_string(),
275            OpRead::new(),
276            OpReader::new().with_concurrent(3).with_chunk(1),
277        ));
278
279        let mut fr = FuturesAsyncReader::new(ctx, 4..8);
280        let chunk = fr.fill_buf().await.unwrap();
281        assert_eq!(chunk, "o".as_bytes());
282
283        fr.consume_unpin(1);
284        let chunk = fr.fill_buf().await.unwrap();
285        assert_eq!(chunk, "W".as_bytes());
286
287        Ok(())
288    }
289}
```
