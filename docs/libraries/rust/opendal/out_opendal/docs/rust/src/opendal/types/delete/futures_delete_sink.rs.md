# 

opendal/types/delete/

futures_delete_sink.rs

``` rust
1// Licensed to the Apache Software Foundation (ASF) under one
2// or more contributor license agreements.  See the NOTICE file
3// distributed with this work for additional information
4// regarding copyright ownership.  The ASF licenses this file
5// to you under the Apache License, Version 2.0 (the
6// "License"); you may not use this file except in compliance
7// with the License.  You may obtain a copy of the License at
8//
9//   http://www.apache.org/licenses/LICENSE-2.0
10//
11// Unless required by applicable law or agreed to in writing,
12// software distributed under the License is distributed on an
13// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
14// KIND, either express or implied.  See the License for the
15// specific language governing permissions and limitations
16// under the License.
17
18use std::marker::PhantomData;
19use std::pin::Pin;
20use std::task::Context;
21use std::task::Poll;
22use std::task::ready;
23
24use futures::Sink;
25
26use crate::raw::*;
27use crate::*;
28
29/// FuturesDeleteSink is a sink that generated by [`Deleter`]
30pub struct FuturesDeleteSink<T: IntoDeleteInput> {
31    state: State,
32    _phantom: PhantomData<T>,
33}
34
35enum State {
36    Idle(Option<Deleter>),
37    Delete(BoxedStaticFuture<(Deleter, Result<()>)>),
38    Flush(BoxedStaticFuture<(Deleter, Result<usize>)>),
39    Close(BoxedStaticFuture<(Deleter, Result<()>)>),
40}
41
42impl<T: IntoDeleteInput> FuturesDeleteSink<T> {
43    #[inline]
44    pub(super) fn new(deleter: Deleter) -> Self {
45        Self {
46            state: State::Idle(Some(deleter)),
47            _phantom: PhantomData,
48        }
49    }
50}
51
52impl<T: IntoDeleteInput> Sink<T> for FuturesDeleteSink<T> {
53    type Error = Error;
54
55    fn poll_ready(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<()>> {
56        match &mut self.state {
57            State::Idle(_) => Poll::Ready(Ok(())),
58            State::Delete(fut) => {
59                let (deleter, res) = ready!(fut.as_mut().poll(cx));
60                self.state = State::Idle(Some(deleter));
61                Poll::Ready(res.map(|_| ()))
62            }
63            State::Flush(fut) => {
64                let (deleter, res) = ready!(fut.as_mut().poll(cx));
65                self.state = State::Idle(Some(deleter));
66                Poll::Ready(res.map(|_| ()))
67            }
68            State::Close(fut) => {
69                let (deleter, res) = ready!(fut.as_mut().poll(cx));
70                self.state = State::Idle(Some(deleter));
71                Poll::Ready(res.map(|_| ()))
72            }
73        }
74    }
75
76    fn start_send(mut self: Pin<&mut Self>, item: T) -> Result<()> {
77        match &mut self.state {
78            State::Idle(deleter) => {
79                let mut deleter = deleter.take().ok_or_else(|| {
80                    Error::new(
81                        ErrorKind::Unexpected,
82                        "FuturesDeleteSink has been closed or errored",
83                    )
84                })?;
85                let input = item.into_delete_input();
86                let fut = async move {
87                    let res = deleter.delete(input).await;
88                    (deleter, res)
89                };
90                self.state = State::Delete(Box::pin(fut));
91                Ok(())
92            }
93            _ => Err(Error::new(
94                ErrorKind::Unexpected,
95                "FuturesDeleteSink is not ready to send, please poll_ready first",
96            )),
97        }
98    }
99
100    fn poll_flush(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<()>> {
101        loop {
102            match &mut self.state {
103                State::Idle(deleter) => {
104                    let mut deleter = deleter.take().ok_or_else(|| {
105                        Error::new(
106                            ErrorKind::Unexpected,
107                            "FuturesDeleteSink has been closed or errored",
108                        )
109                    })?;
110                    let fut = async move {
111                        let res = deleter.flush().await;
112                        (deleter, res)
113                    };
114                    self.state = State::Flush(Box::pin(fut));
115                    return Poll::Ready(Ok(()));
116                }
117                State::Delete(fut) => {
118                    let (deleter, res) = ready!(fut.as_mut().poll(cx));
119                    self.state = State::Idle(Some(deleter));
120                    res?;
121                    continue;
122                }
123                State::Flush(fut) => {
124                    let (deleter, res) = ready!(fut.as_mut().poll(cx));
125                    self.state = State::Idle(Some(deleter));
126                    let _ = res?;
127                    return Poll::Ready(Ok(()));
128                }
129                State::Close(fut) => {
130                    let (deleter, res) = ready!(fut.as_mut().poll(cx));
131                    self.state = State::Idle(Some(deleter));
132                    res?;
133                    continue;
134                }
135            };
136        }
137    }
138
139    fn poll_close(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<()>> {
140        loop {
141            match &mut self.state {
142                State::Idle(deleter) => {
143                    let mut deleter = deleter.take().ok_or_else(|| {
144                        Error::new(
145                            ErrorKind::Unexpected,
146                            "FuturesDeleteSink has been closed or errored",
147                        )
148                    })?;
149                    let fut = async move {
150                        let res = deleter.close().await;
151                        (deleter, res)
152                    };
153                    self.state = State::Close(Box::pin(fut));
154                    return Poll::Ready(Ok(()));
155                }
156                State::Delete(fut) => {
157                    let (deleter, res) = ready!(fut.as_mut().poll(cx));
158                    self.state = State::Idle(Some(deleter));
159                    res?;
160                    continue;
161                }
162                State::Flush(fut) => {
163                    let (deleter, res) = ready!(fut.as_mut().poll(cx));
164                    self.state = State::Idle(Some(deleter));
165                    res?;
166                    continue;
167                }
168                State::Close(fut) => {
169                    let (deleter, res) = ready!(fut.as_mut().poll(cx));
170                    self.state = State::Idle(Some(deleter));
171                    return Poll::Ready(res);
172                }
173            };
174        }
175    }
176}
```
