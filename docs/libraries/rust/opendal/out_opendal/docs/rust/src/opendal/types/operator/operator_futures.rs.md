# 

opendal/types/operator/

operator_futures.rs

``` rust
1// Licensed to the Apache Software Foundation (ASF) under one
2// or more contributor license agreements.  See the NOTICE file
3// distributed with this work for additional information
4// regarding copyright ownership.  The ASF licenses this file
5// to you under the Apache License, Version 2.0 (the
6// "License"); you may not use this file except in compliance
7// with the License.  You may obtain a copy of the License at
8//
9//   http://www.apache.org/licenses/LICENSE-2.0
10//
11// Unless required by applicable law or agreed to in writing,
12// software distributed under the License is distributed on an
13// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
14// KIND, either express or implied.  See the License for the
15// specific language governing permissions and limitations
16// under the License.
17
18//! Futures provides the futures generated by [`Operator`]
19//!
20//! By using futures, users can add more options for operation.
21
22use std::collections::HashMap;
23use std::future::IntoFuture;
24use std::ops::RangeBounds;
25use std::time::Duration;
26
27use crate::raw::*;
28use crate::*;
29use futures::Future;
30
31/// OperatorFuture is the future generated by [`Operator`].
32///
33/// The future will consume all the input to generate a future.
34///
35/// # NOTES
36///
37/// This struct is by design to keep in crate. We don't want
38/// users to use this struct directly.
39pub struct OperatorFuture<I, O, F: Future<Output = Result<O>>> {
40    /// The accessor to the underlying object storage
41    acc: Accessor,
42    /// The path of string
43    path: String,
44    /// The input args
45    args: I,
46    /// The function which will move all the args and return a static future
47    f: fn(Accessor, String, I) -> F,
48}
49
50impl<I, O, F: Future<Output = Result<O>>> OperatorFuture<I, O, F> {
51    /// # NOTES
52    ///
53    /// This struct is by design to keep in crate. We don't want
54    /// users to use this struct directly.
55    pub(crate) fn new(
56        inner: Accessor,
57        path: String,
58        args: I,
59        f: fn(Accessor, String, I) -> F,
60    ) -> Self {
61        OperatorFuture {
62            acc: inner,
63            path,
64            args,
65            f,
66        }
67    }
68}
69
70impl<I, O, F> IntoFuture for OperatorFuture<I, O, F>
71where
72    F: Future<Output = Result<O>>,
73{
74    type Output = Result<O>;
75    type IntoFuture = F;
76
77    fn into_future(self) -> Self::IntoFuture {
78        (self.f)(self.acc, self.path, self.args)
79    }
80}
81
82/// Future that generated by [`Operator::stat_with`].
83///
84/// Users can add more options by public functions provided by this struct.
85pub type FutureStat<F> = OperatorFuture<options::StatOptions, Metadata, F>;
86
87impl<F: Future<Output = Result<Metadata>>> FutureStat<F> {
88    /// Set the If-Match for this operation.
89    ///
90    /// Refer to [`options::StatOptions::if_match`] for more details.
91    pub fn if_match(mut self, v: &str) -> Self {
92        self.args.if_match = Some(v.to_string());
93        self
94    }
95
96    /// Set the If-None-Match for this operation.
97    ///
98    /// Refer to [`options::StatOptions::if_none_match`] for more details.
99    pub fn if_none_match(mut self, v: &str) -> Self {
100        self.args.if_none_match = Some(v.to_string());
101        self
102    }
103
104    /// Set the If-Modified-Since for this operation.
105    ///
106    /// Refer to [`options::StatOptions::if_modified_since`] for more details.
107    pub fn if_modified_since(mut self, v: Timestamp) -> Self {
108        self.args.if_modified_since = Some(v);
109        self
110    }
111
112    /// Set the If-Unmodified-Since for this operation.
113    ///
114    /// Refer to [`options::StatOptions::if_unmodified_since`] for more details.
115    pub fn if_unmodified_since(mut self, v: Timestamp) -> Self {
116        self.args.if_unmodified_since = Some(v);
117        self
118    }
119
120    /// Set the version for this operation.
121    ///
122    /// Refer to [`options::StatOptions::version`] for more details.
123    pub fn version(mut self, v: &str) -> Self {
124        self.args.version = Some(v.to_string());
125        self
126    }
127}
128
129/// Future that generated by [`Operator::presign_stat_with`].
130///
131/// Users can add more options by public functions provided by this struct.
132pub type FuturePresignStat<F> =
133    OperatorFuture<(options::StatOptions, Duration), PresignedRequest, F>;
134
135impl<F: Future<Output = Result<PresignedRequest>>> FuturePresignStat<F> {
136    /// Refer to [`options::StatOptions::override_content_disposition`] for more details.
137    pub fn override_content_disposition(mut self, v: &str) -> Self {
138        self.args.0.override_content_disposition = Some(v.to_string());
139        self
140    }
141
142    /// Refer to [`options::StatOptions::override_cache_control`] for more details.
143    pub fn override_cache_control(mut self, v: &str) -> Self {
144        self.args.0.override_cache_control = Some(v.to_string());
145        self
146    }
147
148    /// Refer to [`options::StatOptions::override_content_type`] for more details.
149    pub fn override_content_type(mut self, v: &str) -> Self {
150        self.args.0.override_content_type = Some(v.to_string());
151        self
152    }
153
154    /// Refer to [`options::StatOptions::if_match`] for more details.
155    pub fn if_match(mut self, v: &str) -> Self {
156        self.args.0.if_match = Some(v.to_string());
157        self
158    }
159
160    /// Refer to [`options::StatOptions::if_none_match`] for more details.
161    pub fn if_none_match(mut self, v: &str) -> Self {
162        self.args.0.if_none_match = Some(v.to_string());
163        self
164    }
165}
166
167/// Future that generated by [`Operator::presign_delete_with`].
168///
169/// Users can add more options by public functions provided by this struct.
170pub type FuturePresignDelete<F> =
171    OperatorFuture<(options::DeleteOptions, Duration), PresignedRequest, F>;
172
173impl<F: Future<Output = Result<PresignedRequest>>> FuturePresignDelete<F> {}
174
175/// Future that generated by [`Operator::presign_read_with`].
176///
177/// Users can add more options by public functions provided by this struct.
178pub type FuturePresignRead<F> =
179    OperatorFuture<(options::ReadOptions, Duration), PresignedRequest, F>;
180
181impl<F: Future<Output = Result<PresignedRequest>>> FuturePresignRead<F> {
182    /// Refer to [`options::ReadOptions::override_content_disposition`] for more details.
183    pub fn override_content_disposition(mut self, v: &str) -> Self {
184        self.args.0.override_content_disposition = Some(v.to_string());
185        self
186    }
187
188    /// Refer to [`options::ReadOptions::override_cache_control`] for more details.
189    pub fn override_cache_control(mut self, v: &str) -> Self {
190        self.args.0.override_cache_control = Some(v.to_string());
191        self
192    }
193
194    /// Refer to [`options::ReadOptions::override_content_type`] for more details.
195    pub fn override_content_type(mut self, v: &str) -> Self {
196        self.args.0.override_content_type = Some(v.to_string());
197        self
198    }
199
200    /// Refer to [`options::ReadOptions::if_match`] for more details.
201    pub fn if_match(mut self, v: &str) -> Self {
202        self.args.0.if_match = Some(v.to_string());
203        self
204    }
205
206    /// Refer to [`options::ReadOptions::if_none_match`] for more details.
207    pub fn if_none_match(mut self, v: &str) -> Self {
208        self.args.0.if_none_match = Some(v.to_string());
209        self
210    }
211}
212
213/// Future that generated by [`Operator::presign_write_with`].
214///
215/// Users can add more options by public functions provided by this struct.
216pub type FuturePresignWrite<F> =
217    OperatorFuture<(options::WriteOptions, Duration), PresignedRequest, F>;
218
219impl<F: Future<Output = Result<PresignedRequest>>> FuturePresignWrite<F> {
220    /// Refer to [`options::WriteOptions::content_type`] for more details.
221    pub fn content_type(mut self, v: &str) -> Self {
222        self.args.0.content_type = Some(v.to_string());
223        self
224    }
225
226    /// Refer to [`options::WriteOptions::content_disposition`] for more details.
227    pub fn content_disposition(mut self, v: &str) -> Self {
228        self.args.0.content_disposition = Some(v.to_string());
229        self
230    }
231
232    /// Refer to [`options::WriteOptions::content_encoding`] for more details.
233    pub fn content_encoding(mut self, v: &str) -> Self {
234        self.args.0.content_encoding = Some(v.to_string());
235        self
236    }
237
238    /// Refer to [`options::WriteOptions::cache_control`] for more details.
239    pub fn cache_control(mut self, v: &str) -> Self {
240        self.args.0.cache_control = Some(v.to_string());
241        self
242    }
243}
244
245/// Future that generated by [`Operator::read_with`].
246///
247/// Users can add more options by public functions provided by this struct.
248pub type FutureRead<F> = OperatorFuture<options::ReadOptions, Buffer, F>;
249
250impl<F: Future<Output = Result<Buffer>>> FutureRead<F> {
251    /// Set `range` for this `read` request.
252    ///
253    /// If we have a file with size `n`.
254    ///
255    /// - `..` means read bytes in range `[0, n)` of file.
256    /// - `0..1024` and `..1024` means read bytes in range `[0, 1024)` of file
257    /// - `1024..` means read bytes in range `[1024, n)` of file
258    ///
259    /// ```
260    /// # use opendal::Result;
261    /// # use opendal::Operator;
262    /// # use futures::TryStreamExt;
263    /// # async fn test(op: Operator) -> Result<()> {
264    /// let bs = op.read_with("path/to/file").range(0..1024).await?;
265    /// # Ok(())
266    /// # }
267    /// ```
268    pub fn range(mut self, range: impl RangeBounds<u64>) -> Self {
269        self.args.range = range.into();
270        self
271    }
272
273    /// Set `concurrent` for the reader.
274    ///
275    /// OpenDAL by default to write file without concurrent. This is not efficient for cases when users
276    /// read large chunks of data. By setting `concurrent`, opendal will read files concurrently
277    /// on support storage services.
278    ///
279    /// By setting `concurrent`, opendal will fetch chunks concurrently with
280    /// the given chunk size.
281    ///
282    /// ```
283    /// # use opendal::Result;
284    /// # use opendal::Operator;
285    /// # use opendal::Scheme;
286    /// # async fn test(op: Operator) -> Result<()> {
287    /// let r = op.read_with("path/to/file").concurrent(8).await?;
288    /// # Ok(())
289    /// # }
290    /// ```
291    pub fn concurrent(mut self, concurrent: usize) -> Self {
292        self.args.concurrent = concurrent.max(1);
293        self
294    }
295
296    /// OpenDAL will use services' preferred chunk size by default. Users can set chunk based on their own needs.
297    ///
298    /// This following example will make opendal read data in 4MiB chunks:
299    ///
300    /// ```
301    /// # use opendal::Result;
302    /// # use opendal::Operator;
303    /// # use opendal::Scheme;
304    /// # async fn test(op: Operator) -> Result<()> {
305    /// let r = op.read_with("path/to/file").chunk(4 * 1024 * 1024).await?;
306    /// # Ok(())
307    /// # }
308    /// ```
309    pub fn chunk(mut self, chunk_size: usize) -> Self {
310        self.args.chunk = Some(chunk_size);
311        self
312    }
313
314    /// Set `version` for this `read` request.
315    ///
316    /// This feature can be used to retrieve the data of a specified version of the given path.
317    ///
318    /// If the version doesn't exist, an error with kind [`ErrorKind::NotFound`] will be returned.
319    ///
320    /// ```
321    /// # use opendal::Result;
322    /// # use opendal::Operator;
323    ///
324    /// # async fn test(op: Operator, version: &str) -> Result<()> {
325    /// let mut bs = op.read_with("path/to/file").version(version).await?;
326    /// # Ok(())
327    /// # }
328    /// ```
329    pub fn version(mut self, v: &str) -> Self {
330        self.args.version = Some(v.to_string());
331        self
332    }
333
334    /// Set `if_match` for this `read` request.
335    ///
336    /// This feature can be used to check if the file's `ETag` matches the given `ETag`.
337    ///
338    /// If file exists and it's etag doesn't match, an error with kind [`ErrorKind::ConditionNotMatch`]
339    /// will be returned.
340    ///
341    /// ```
342    /// # use opendal::Result;
343    /// use opendal::Operator;
344    /// # async fn test(op: Operator, etag: &str) -> Result<()> {
345    /// let mut metadata = op.read_with("path/to/file").if_match(etag).await?;
346    /// # Ok(())
347    /// # }
348    /// ```
349    pub fn if_match(mut self, v: &str) -> Self {
350        self.args.if_match = Some(v.to_string());
351        self
352    }
353
354    /// Set `if_none_match` for this `read` request.
355    ///
356    /// This feature can be used to check if the file's `ETag` doesn't match the given `ETag`.
357    ///
358    /// If file exists and it's etag match, an error with kind [`ErrorKind::ConditionNotMatch`]
359    /// will be returned.
360    ///
361    /// ```
362    /// # use opendal::Result;
363    /// use opendal::Operator;
364    /// # async fn test(op: Operator, etag: &str) -> Result<()> {
365    /// let mut metadata = op.read_with("path/to/file").if_none_match(etag).await?;
366    /// # Ok(())
367    /// # }
368    /// ```
369    pub fn if_none_match(mut self, v: &str) -> Self {
370        self.args.if_none_match = Some(v.to_string());
371        self
372    }
373
374    /// ## `if_modified_since`
375    ///
376    /// Set `if_modified_since` for this `read` request.
377    ///
378    /// This feature can be used to check if the file has been modified since the given timestamp.
379    ///
380    /// If file exists and it hasn't been modified since the specified time, an error with kind
381    /// [`ErrorKind::ConditionNotMatch`] will be returned.
382    ///
383    /// ```
384    /// # use opendal::Result;
385    /// use jiff::Timestamp;
386    /// use opendal::Operator;
387    /// # async fn test(op: Operator, time: Timestamp) -> Result<()> {
388    /// let mut metadata = op.read_with("path/to/file").if_modified_since(time).await?;
389    /// # Ok(())
390    /// # }
391    /// ```
392    pub fn if_modified_since(mut self, v: impl Into<Timestamp>) -> Self {
393        self.args.if_modified_since = Some(v.into());
394        self
395    }
396
397    /// Set `if_unmodified_since` for this `read` request.
398    ///
399    /// This feature can be used to check if the file hasn't been modified since the given timestamp.
400    ///
401    /// If file exists and it has been modified since the specified time, an error with kind
402    /// [`ErrorKind::ConditionNotMatch`] will be returned.
403    ///
404    /// ```
405    /// # use opendal::Result;
406    /// use jiff::Timestamp;
407    /// use opendal::Operator;
408    /// # async fn test(op: Operator, time: Timestamp) -> Result<()> {
409    /// let mut metadata = op
410    ///     .read_with("path/to/file")
411    ///     .if_unmodified_since(time)
412    ///     .await?;
413    /// # Ok(())
414    /// # }
415    /// ```
416    pub fn if_unmodified_since(mut self, v: impl Into<Timestamp>) -> Self {
417        self.args.if_unmodified_since = Some(v.into());
418        self
419    }
420}
421
422/// Future that generated by [`Operator::read_with`] or [`Operator::reader_with`].
423///
424/// Users can add more options by public functions provided by this struct.
425///
426/// # Notes
427///
428/// `(OpRead, ())` is a trick to make sure `FutureReader` is different from `FutureRead`
429pub type FutureReader<F> = OperatorFuture<options::ReaderOptions, Reader, F>;
430
431impl<F: Future<Output = Result<Reader>>> FutureReader<F> {
432    /// Set `version` for this `reader`.
433    ///
434    /// This feature can be used to retrieve the data of a specified version of the given path.
435    ///
436    /// If the version doesn't exist, an error with kind [`ErrorKind::NotFound`] will be returned.
437    ///
438    /// ```
439    /// # use opendal::Result;
440    /// # use opendal::Operator;
441    ///
442    /// # async fn test(op: Operator, version: &str) -> Result<()> {
443    /// let mut r = op.reader_with("path/to/file").version(version).await?;
444    /// # Ok(())
445    /// # }
446    /// ```
447    pub fn version(mut self, v: &str) -> Self {
448        self.args.version = Some(v.to_string());
449        self
450    }
451
452    /// Set `concurrent` for the reader.
453    ///
454    /// OpenDAL by default to write file without concurrent. This is not efficient for cases when users
455    /// read large chunks of data. By setting `concurrent`, opendal will reading files concurrently
456    /// on support storage services.
457    ///
458    /// By setting `concurrent`, opendal will fetch chunks concurrently with
459    /// the give chunk size.
460    ///
461    /// ```
462    /// # use opendal::Result;
463    /// # use opendal::Operator;
464    /// # use opendal::Scheme;
465    /// # async fn test(op: Operator) -> Result<()> {
466    /// let r = op.reader_with("path/to/file").concurrent(8).await?;
467    /// # Ok(())
468    /// # }
469    /// ```
470    pub fn concurrent(mut self, concurrent: usize) -> Self {
471        self.args.concurrent = concurrent.max(1);
472        self
473    }
474
475    /// OpenDAL will use services' preferred chunk size by default. Users can set chunk based on their own needs.
476    ///
477    /// This following example will make opendal read data in 4MiB chunks:
478    ///
479    /// ```
480    /// # use opendal::Result;
481    /// # use opendal::Operator;
482    /// # use opendal::Scheme;
483    /// # async fn test(op: Operator) -> Result<()> {
484    /// let r = op
485    ///     .reader_with("path/to/file")
486    ///     .chunk(4 * 1024 * 1024)
487    ///     .await?;
488    /// # Ok(())
489    /// # }
490    /// ```
491    pub fn chunk(mut self, chunk_size: usize) -> Self {
492        self.args.chunk = Some(chunk_size);
493        self
494    }
495
496    /// Controls the optimization strategy for range reads in [`Reader::fetch`].
497    ///
498    /// When performing range reads, if the gap between two requested ranges is smaller than
499    /// the configured `gap` size, OpenDAL will merge these ranges into a single read request
500    /// and discard the unrequested data in between. This helps reduce the number of API calls
501    /// to remote storage services.
502    ///
503    /// This optimization is particularly useful when performing multiple small range reads
504    /// that are close to each other, as it reduces the overhead of multiple network requests
505    /// at the cost of transferring some additional data.
506    ///
507    /// In this example, if two requested ranges are separated by less than 1MiB,
508    /// they will be merged into a single read request:
509    ///
510    /// ```
511    /// # use opendal::Result;
512    /// # use opendal::Operator;
513    /// # use opendal::Scheme;
514    /// # async fn test(op: Operator) -> Result<()> {
515    /// let r = op
516    ///     .reader_with("path/to/file")
517    ///     .chunk(4 * 1024 * 1024)
518    ///     .gap(1024 * 1024) // 1MiB gap
519    ///     .await?;
520    /// # Ok(())
521    /// # }
522    /// ```
523    pub fn gap(mut self, gap_size: usize) -> Self {
524        self.args.gap = Some(gap_size);
525        self
526    }
527
528    /// Set `if-match` for this `read` request.
529    ///
530    /// This feature can be used to check if the file's `ETag` matches the given `ETag`.
531    ///
532    /// If file exists and it's etag doesn't match, an error with kind [`ErrorKind::ConditionNotMatch`]
533    /// will be returned.
534    ///
535    /// ```
536    /// # use opendal::Result;
537    /// use opendal::Operator;
538    /// # async fn test(op: Operator, etag: &str) -> Result<()> {
539    /// let mut r = op.reader_with("path/to/file").if_match(etag).await?;
540    /// # Ok(())
541    /// # }
542    /// ```
543    pub fn if_match(mut self, etag: &str) -> Self {
544        self.args.if_match = Some(etag.to_string());
545        self
546    }
547
548    /// Set `if-none-match` for this `read` request.
549    ///
550    /// This feature can be used to check if the file's `ETag` doesn't match the given `ETag`.
551    ///
552    /// If file exists and it's etag match, an error with kind [`ErrorKind::ConditionNotMatch`]
553    /// will be returned.
554    ///
555    /// ```
556    /// # use opendal::Result;
557    /// use opendal::Operator;
558    /// # async fn test(op: Operator, etag: &str) -> Result<()> {
559    /// let mut r = op.reader_with("path/to/file").if_none_match(etag).await?;
560    /// # Ok(())
561    /// # }
562    /// ```
563    pub fn if_none_match(mut self, etag: &str) -> Self {
564        self.args.if_none_match = Some(etag.to_string());
565        self
566    }
567
568    /// Set `if-modified-since` for this `read` request.
569    ///
570    /// This feature can be used to check if the file has been modified since the given timestamp.
571    ///
572    /// If file exists and it hasn't been modified since the specified time, an error with kind
573    /// [`ErrorKind::ConditionNotMatch`] will be returned.
574    ///
575    /// ```
576    /// # use opendal::Result;
577    /// use jiff::Timestamp;
578    /// use opendal::Operator;
579    /// # async fn test(op: Operator, time: Timestamp) -> Result<()> {
580    /// let mut r = op
581    ///     .reader_with("path/to/file")
582    ///     .if_modified_since(time)
583    ///     .await?;
584    /// # Ok(())
585    /// # }
586    /// ```
587    pub fn if_modified_since(mut self, v: impl Into<Timestamp>) -> Self {
588        self.args.if_modified_since = Some(v.into());
589        self
590    }
591
592    /// Set `if-unmodified-since` for this `read` request.
593    ///
594    /// This feature can be used to check if the file hasn't been modified since the given timestamp.
595    ///
596    /// If file exists and it has been modified since the specified time, an error with kind
597    /// [`ErrorKind::ConditionNotMatch`] will be returned.
598    ///
599    /// ```
600    /// # use opendal::Result;
601    /// use jiff::Timestamp;
602    /// use opendal::Operator;
603    /// # async fn test(op: Operator, time: Timestamp) -> Result<()> {
604    /// let mut r = op
605    ///     .reader_with("path/to/file")
606    ///     .if_unmodified_since(time)
607    ///     .await?;
608    /// # Ok(())
609    /// # }
610    /// ```
611    pub fn if_unmodified_since(mut self, v: impl Into<Timestamp>) -> Self {
612        self.args.if_unmodified_since = Some(v.into());
613        self
614    }
615}
616
617/// Future that generated by [`Operator::write_with`].
618///
619/// Users can add more options by public functions provided by this struct.
620pub type FutureWrite<F> = OperatorFuture<(options::WriteOptions, Buffer), Metadata, F>;
621
622impl<F: Future<Output = Result<Metadata>>> FutureWrite<F> {
623    /// Sets append mode for this write request.
624    ///
625    /// Refer to [`options::WriteOptions::append`] for more details.
626    ///
627    /// ### Example
628    ///
629    /// ```
630    /// # use opendal::Result;
631    /// # use opendal::Operator;
632    /// # use futures::StreamExt;
633    /// # use futures::SinkExt;
634    /// use bytes::Bytes;
635    ///
636    /// # async fn test(op: Operator) -> Result<()> {
637    /// let _ = op
638    ///     .write_with("path/to/file", vec![0; 4096])
639    ///     .append(true)
640    ///     .await?;
641    /// # Ok(())
642    /// # }
643    /// ```
644    pub fn append(mut self, v: bool) -> Self {
645        self.args.0.append = v;
646        self
647    }
648
649    /// Sets chunk size for buffered writes.
650    ///
651    /// Refer to [`options::WriteOptions::chunk`] for more details.
652    ///
653    /// ### Example
654    ///
655    /// ```
656    /// # use opendal::Result;
657    /// # use opendal::Operator;
658    /// # use futures::StreamExt;
659    /// # use futures::SinkExt;
660    /// use bytes::Bytes;
661    ///
662    /// # async fn test(op: Operator) -> Result<()> {
663    /// // Set 8MiB chunk size - data will be sent in one API call at close
664    /// let _ = op
665    ///     .write_with("path/to/file", vec![0; 4096])
666    ///     .chunk(8 * 1024 * 1024)
667    ///     .await?;
668    /// # Ok(())
669    /// # }
670    /// ```
671    pub fn chunk(mut self, v: usize) -> Self {
672        self.args.0.chunk = Some(v);
673        self
674    }
675
676    /// Sets concurrent write operations for this writer.
677    ///
678    /// Refer to [`options::WriteOptions::concurrent`] for more details.
679    ///
680    /// ## Example
681    ///
682    /// ```
683    /// # use opendal::Result;
684    /// # use opendal::Operator;
685    /// # use futures::StreamExt;
686    /// # use futures::SinkExt;
687    /// use bytes::Bytes;
688    ///
689    /// # async fn test(op: Operator) -> Result<()> {
690    /// // Enable concurrent writes with 8 parallel operations at 128B chunk.
691    /// let _ = op
692    ///     .write_with("path/to/file", vec![0; 4096])
693    ///     .chunk(128)
694    ///     .concurrent(8)
695    ///     .await?;
696    /// # Ok(())
697    /// # }
698    /// ```
699    pub fn concurrent(mut self, v: usize) -> Self {
700        self.args.0.concurrent = v.max(1);
701        self
702    }
703
704    /// Sets Cache-Control header for this write operation.
705    ///
706    /// Refer to [`options::WriteOptions::cache_control`] for more details.
707    ///
708    /// ### Example
709    ///
710    /// ```
711    /// # use opendal::Result;
712    /// # use opendal::Operator;
713    /// # use futures::StreamExt;
714    /// # use futures::SinkExt;
715    /// use bytes::Bytes;
716    ///
717    /// # async fn test(op: Operator) -> Result<()> {
718    /// // Cache content for 7 days (604800 seconds)
719    /// let _ = op
720    ///     .write_with("path/to/file", vec![0; 4096])
721    ///     .cache_control("max-age=604800")
722    ///     .await?;
723    /// # Ok(())
724    /// # }
725    /// ```
726    pub fn cache_control(mut self, v: &str) -> Self {
727        self.args.0.cache_control = Some(v.to_string());
728        self
729    }
730
731    /// Sets `Content-Type` header for this write operation.
732    ///
733    /// Refer to [`options::WriteOptions::content_type`] for more details.
734    ///
735    /// ## Example
736    ///
737    /// ```
738    /// # use opendal::Result;
739    /// # use opendal::Operator;
740    /// use bytes::Bytes;
741    ///
742    /// # async fn test(op: Operator) -> Result<()> {
743    /// // Set content type for plain text file
744    /// let _ = op
745    ///     .write_with("path/to/file", vec![0; 4096])
746    ///     .content_type("text/plain")
747    ///     .await?;
748    /// # Ok(())
749    /// # }
750    /// ```
751    pub fn content_type(mut self, v: &str) -> Self {
752        self.args.0.content_type = Some(v.to_string());
753        self
754    }
755
756    /// Sets Content-Disposition header for this write request.
757    ///
758    /// Refer to [`options::WriteOptions::content_disposition`] for more details.
759    ///
760    /// ### Example
761    ///
762    /// ```
763    /// # use opendal::Result;
764    /// # use opendal::Operator;
765    /// # use futures::StreamExt;
766    /// # use futures::SinkExt;
767    /// use bytes::Bytes;
768    ///
769    /// # async fn test(op: Operator) -> Result<()> {
770    /// let _ = op
771    ///     .write_with("path/to/file", vec![0; 4096])
772    ///     .content_disposition("attachment; filename=\"filename.jpg\"")
773    ///     .await?;
774    /// # Ok(())
775    /// # }
776    /// ```
777    pub fn content_disposition(mut self, v: &str) -> Self {
778        self.args.0.content_disposition = Some(v.to_string());
779        self
780    }
781
782    /// Sets Content-Encoding header for this write request.
783    ///
784    /// Refer to [`options::WriteOptions::content_encoding`] for more details.
785    ///
786    /// ### Example
787    ///
788    /// ```
789    /// # use opendal::Result;
790    /// # use opendal::Operator;
791    /// # use futures::StreamExt;
792    /// # use futures::SinkExt;
793    /// use bytes::Bytes;
794    ///
795    /// # async fn test(op: Operator) -> Result<()> {
796    /// let _ = op
797    ///     .write_with("path/to/file", vec![0; 4096])
798    ///     .content_encoding("gzip")
799    ///     .await?;
800    /// # Ok(())
801    /// # }
802    /// ```
803    pub fn content_encoding(mut self, v: &str) -> Self {
804        self.args.0.content_encoding = Some(v.to_string());
805        self
806    }
807
808    /// Sets If-Match header for this write request.
809    ///
810    /// Refer to [`options::WriteOptions::if_match`] for more details.
811    ///
812    /// ### Example
813    ///
814    /// ```
815    /// # use opendal::Result;
816    /// # use opendal::Operator;
817    /// # use futures::StreamExt;
818    /// # use futures::SinkExt;
819    /// use bytes::Bytes;
820    ///
821    /// # async fn test(op: Operator) -> Result<()> {
822    /// let _ = op
823    ///     .write_with("path/to/file", vec![0; 4096])
824    ///     .if_match("\"686897696a7c876b7e\"")
825    ///     .await?;
826    /// # Ok(())
827    /// # }
828    /// ```
829    pub fn if_match(mut self, s: &str) -> Self {
830        self.args.0.if_match = Some(s.to_string());
831        self
832    }
833
834    /// Sets If-None-Match header for this write request.
835    ///
836    /// Refer to [`options::WriteOptions::if_none_match`] for more details.
837    ///
838    /// ### Example
839    ///
840    /// ```
841    /// # use opendal::Result;
842    /// # use opendal::Operator;
843    /// # use futures::StreamExt;
844    /// # use futures::SinkExt;
845    /// use bytes::Bytes;
846    ///
847    /// # async fn test(op: Operator) -> Result<()> {
848    /// let _ = op
849    ///     .write_with("path/to/file", vec![0; 4096])
850    ///     .if_none_match("\"686897696a7c876b7e\"")
851    ///     .await?;
852    /// # Ok(())
853    /// # }
854    /// ```
855    pub fn if_none_match(mut self, s: &str) -> Self {
856        self.args.0.if_none_match = Some(s.to_string());
857        self
858    }
859
860    /// Sets the condition that write operation will succeed only if target does not exist.
861    ///
862    /// Refer to [`options::WriteOptions::if_not_exists`] for more details.
863    ///
864    /// ### Example
865    ///
866    /// ```
867    /// # use opendal::Result;
868    /// # use opendal::Operator;
869    /// # use futures::StreamExt;
870    /// # use futures::SinkExt;
871    /// use bytes::Bytes;
872    ///
873    /// # async fn test(op: Operator) -> Result<()> {
874    /// let _ = op
875    ///     .write_with("path/to/file", vec![0; 4096])
876    ///     .if_not_exists(true)
877    ///     .await?;
878    /// # Ok(())
879    /// # }
880    /// ```
881    pub fn if_not_exists(mut self, b: bool) -> Self {
882        self.args.0.if_not_exists = b;
883        self
884    }
885
886    /// Sets user metadata for this write request.
887    ///
888    /// Refer to [`options::WriteOptions::user_metadata`] for more details.
889    ///
890    /// ### Example
891    ///
892    /// ```
893    /// # use opendal::Result;
894    /// # use opendal::Operator;
895    /// # use futures::StreamExt;
896    /// # use futures::SinkExt;
897    /// use bytes::Bytes;
898    ///
899    /// # async fn test(op: Operator) -> Result<()> {
900    /// let _ = op
901    ///     .write_with("path/to/file", vec![0; 4096])
902    ///     .user_metadata([
903    ///         ("language".to_string(), "rust".to_string()),
904    ///         ("author".to_string(), "OpenDAL".to_string()),
905    ///     ])
906    ///     .await?;
907    /// # Ok(())
908    /// # }
909    /// ```
910    pub fn user_metadata(mut self, data: impl IntoIterator<Item = (String, String)>) -> Self {
911        self.args.0.user_metadata = Some(HashMap::from_iter(data));
912        self
913    }
914}
915
916/// Future that generated by [`Operator::writer_with`].
917///
918/// Users can add more options by public functions provided by this struct.
919pub type FutureWriter<F> = OperatorFuture<options::WriteOptions, Writer, F>;
920
921impl<F: Future<Output = Result<Writer>>> FutureWriter<F> {
922    /// Sets append mode for this write request.
923    ///
924    /// Refer to [`options::WriteOptions::append`] for more details.
925    ///
926    /// ### Example
927    ///
928    /// ```
929    /// # use opendal::Result;
930    /// # use opendal::Operator;
931    /// # use futures::StreamExt;
932    /// # use futures::SinkExt;
933    /// use bytes::Bytes;
934    ///
935    /// # async fn test(op: Operator) -> Result<()> {
936    /// let mut w = op.writer_with("path/to/file").append(true).await?;
937    /// w.write(vec![0; 4096]).await?;
938    /// w.write(vec![1; 4096]).await?;
939    /// w.close().await?;
940    /// # Ok(())
941    /// # }
942    /// ```
943    pub fn append(mut self, v: bool) -> Self {
944        self.args.append = v;
945        self
946    }
947
948    /// Sets chunk size for buffered writes.
949    ///
950    /// Refer to [`options::WriteOptions::chunk`] for more details.
951    ///
952    /// ### Example
953    ///
954    /// ```
955    /// # use opendal::Result;
956    /// # use opendal::Operator;
957    /// # use futures::StreamExt;
958    /// # use futures::SinkExt;
959    /// use bytes::Bytes;
960    ///
961    /// # async fn test(op: Operator) -> Result<()> {
962    /// // Set 8MiB chunk size - data will be sent in one API call at close
963    /// let mut w = op
964    ///     .writer_with("path/to/file")
965    ///     .chunk(8 * 1024 * 1024)
966    ///     .await?;
967    /// w.write(vec![0; 4096]).await?;
968    /// w.write(vec![1; 4096]).await?;
969    /// w.close().await?;
970    /// # Ok(())
971    /// # }
972    /// ```
973    pub fn chunk(mut self, v: usize) -> Self {
974        self.args.chunk = Some(v);
975        self
976    }
977
978    /// Sets concurrent write operations for this writer.
979    ///
980    /// Refer to [`options::WriteOptions::concurrent`] for more details.
981    ///
982    /// ## Example
983    ///
984    /// ```
985    /// # use opendal::Result;
986    /// # use opendal::Operator;
987    /// # use futures::StreamExt;
988    /// # use futures::SinkExt;
989    /// use bytes::Bytes;
990    ///
991    /// # async fn test(op: Operator) -> Result<()> {
992    /// // Enable concurrent writes with 8 parallel operations
993    /// let mut w = op.writer_with("path/to/file").concurrent(8).await?;
994    ///
995    /// // First write starts immediately
996    /// w.write(vec![0; 4096]).await?;
997    ///
998    /// // Second write runs concurrently with first
999    /// w.write(vec![1; 4096]).await?;
1000    ///
1001    /// // Ensures all writes complete successfully and in order
1002    /// w.close().await?;
1003    /// # Ok(())
1004    /// # }
1005    /// ```
1006    pub fn concurrent(mut self, v: usize) -> Self {
1007        self.args.concurrent = v.max(1);
1008        self
1009    }
1010
1011    /// Sets Cache-Control header for this write operation.
1012    ///
1013    /// Refer to [`options::WriteOptions::cache_control`] for more details.
1014    ///
1015    /// ### Example
1016    ///
1017    /// ```
1018    /// # use opendal::Result;
1019    /// # use opendal::Operator;
1020    /// # use futures::StreamExt;
1021    /// # use futures::SinkExt;
1022    /// use bytes::Bytes;
1023    ///
1024    /// # async fn test(op: Operator) -> Result<()> {
1025    /// // Cache content for 7 days (604800 seconds)
1026    /// let mut w = op
1027    ///     .writer_with("path/to/file")
1028    ///     .cache_control("max-age=604800")
1029    ///     .await?;
1030    /// w.write(vec![0; 4096]).await?;
1031    /// w.write(vec![1; 4096]).await?;
1032    /// w.close().await?;
1033    /// # Ok(())
1034    /// # }
1035    /// ```
1036    pub fn cache_control(mut self, v: &str) -> Self {
1037        self.args.cache_control = Some(v.to_string());
1038        self
1039    }
1040
1041    /// Sets `Content-Type` header for this write operation.
1042    ///
1043    /// Refer to [`options::WriteOptions::content_type`] for more details.
1044    ///
1045    /// ## Example
1046    ///
1047    /// ```
1048    /// # use opendal::Result;
1049    /// # use opendal::Operator;
1050    /// use bytes::Bytes;
1051    ///
1052    /// # async fn test(op: Operator) -> Result<()> {
1053    /// // Set content type for plain text file
1054    /// let mut w = op
1055    ///     .writer_with("path/to/file")
1056    ///     .content_type("text/plain")
1057    ///     .await?;
1058    /// w.write(vec![0; 4096]).await?;
1059    /// w.write(vec![1; 4096]).await?;
1060    /// w.close().await?;
1061    /// # Ok(())
1062    /// # }
1063    /// ```
1064    pub fn content_type(mut self, v: &str) -> Self {
1065        self.args.content_type = Some(v.to_string());
1066        self
1067    }
1068
1069    /// Sets Content-Disposition header for this write request.
1070    ///
1071    /// Refer to [`options::WriteOptions::content_disposition`] for more details.
1072    ///
1073    /// ### Example
1074    ///
1075    /// ```
1076    /// # use opendal::Result;
1077    /// # use opendal::Operator;
1078    /// # use futures::StreamExt;
1079    /// # use futures::SinkExt;
1080    /// use bytes::Bytes;
1081    ///
1082    /// # async fn test(op: Operator) -> Result<()> {
1083    /// let mut w = op
1084    ///     .writer_with("path/to/file")
1085    ///     .content_disposition("attachment; filename=\"filename.jpg\"")
1086    ///     .await?;
1087    /// w.write(vec![0; 4096]).await?;
1088    /// w.write(vec![1; 4096]).await?;
1089    /// w.close().await?;
1090    /// # Ok(())
1091    /// # }
1092    /// ```
1093    pub fn content_disposition(mut self, v: &str) -> Self {
1094        self.args.content_disposition = Some(v.to_string());
1095        self
1096    }
1097
1098    /// Sets Content-Encoding header for this write request.
1099    ///
1100    /// Refer to [`options::WriteOptions::content_encoding`] for more details.
1101    ///
1102    /// ### Example
1103    ///
1104    /// ```
1105    /// # use opendal::Result;
1106    /// # use opendal::Operator;
1107    /// # use futures::StreamExt;
1108    /// # use futures::SinkExt;
1109    /// use bytes::Bytes;
1110    ///
1111    /// # async fn test(op: Operator) -> Result<()> {
1112    /// let mut w = op
1113    ///     .writer_with("path/to/file")
1114    ///     .content_encoding("gzip")
1115    ///     .await?;
1116    /// w.write(vec![0; 4096]).await?;
1117    /// w.write(vec![1; 4096]).await?;
1118    /// w.close().await?;
1119    /// # Ok(())
1120    /// # }
1121    /// ```
1122    pub fn content_encoding(mut self, v: &str) -> Self {
1123        self.args.content_encoding = Some(v.to_string());
1124        self
1125    }
1126
1127    /// Sets If-Match header for this write request.
1128    ///
1129    /// Refer to [`options::WriteOptions::if_match`] for more details.
1130    ///
1131    /// ### Behavior
1132    ///
1133    /// - If supported, the write operation will only succeed if the target's ETag matches the specified value
1134    /// - The value should be a valid ETag string
1135    /// - Common values include:
1136    ///   - A specific ETag value like `"686897696a7c876b7e"`
1137    ///   - `*` - Matches any existing resource
1138    /// - If not supported, the value will be ignored
1139    ///
1140    /// This operation provides conditional write functionality based on ETag matching,
1141    /// helping prevent unintended overwrites in concurrent scenarios.
1142    ///
1143    /// ### Example
1144    ///
1145    /// ```
1146    /// # use opendal::Result;
1147    /// # use opendal::Operator;
1148    /// # use futures::StreamExt;
1149    /// # use futures::SinkExt;
1150    /// use bytes::Bytes;
1151    ///
1152    /// # async fn test(op: Operator) -> Result<()> {
1153    /// let mut w = op
1154    ///     .writer_with("path/to/file")
1155    ///     .if_match("\"686897696a7c876b7e\"")
1156    ///     .await?;
1157    /// w.write(vec![0; 4096]).await?;
1158    /// w.write(vec![1; 4096]).await?;
1159    /// w.close().await?;
1160    /// # Ok(())
1161    /// # }
1162    /// ```
1163    pub fn if_match(mut self, s: &str) -> Self {
1164        self.args.if_match = Some(s.to_string());
1165        self
1166    }
1167
1168    /// Sets If-None-Match header for this write request.
1169    ///
1170    /// Refer to [`options::WriteOptions::if_none_match`] for more details.
1171    ///
1172    /// ### Example
1173    ///
1174    /// ```
1175    /// # use opendal::Result;
1176    /// # use opendal::Operator;
1177    /// # use futures::StreamExt;
1178    /// # use futures::SinkExt;
1179    /// use bytes::Bytes;
1180    ///
1181    /// # async fn test(op: Operator) -> Result<()> {
1182    /// let mut w = op
1183    ///     .writer_with("path/to/file")
1184    ///     .if_none_match("\"686897696a7c876b7e\"")
1185    ///     .await?;
1186    /// w.write(vec![0; 4096]).await?;
1187    /// w.write(vec![1; 4096]).await?;
1188    /// w.close().await?;
1189    /// # Ok(())
1190    /// # }
1191    /// ```
1192    pub fn if_none_match(mut self, s: &str) -> Self {
1193        self.args.if_none_match = Some(s.to_string());
1194        self
1195    }
1196
1197    /// Sets the condition that write operation will succeed only if target does not exist.
1198    ///
1199    /// Refer to [`options::WriteOptions::if_not_exists`] for more details.
1200    ///
1201    /// ### Example
1202    ///
1203    /// ```
1204    /// # use opendal::Result;
1205    /// # use opendal::Operator;
1206    /// # use futures::StreamExt;
1207    /// # use futures::SinkExt;
1208    /// use bytes::Bytes;
1209    ///
1210    /// # async fn test(op: Operator) -> Result<()> {
1211    /// let mut w = op.writer_with("path/to/file").if_not_exists(true).await?;
1212    /// w.write(vec![0; 4096]).await?;
1213    /// w.write(vec![1; 4096]).await?;
1214    /// w.close().await?;
1215    /// # Ok(())
1216    /// # }
1217    /// ```
1218    pub fn if_not_exists(mut self, b: bool) -> Self {
1219        self.args.if_not_exists = b;
1220        self
1221    }
1222
1223    /// Sets user metadata for this write request.
1224    ///
1225    /// Refer to [`options::WriteOptions::user_metadata`] for more details.
1226    ///
1227    /// ### Example
1228    ///
1229    /// ```
1230    /// # use opendal::Result;
1231    /// # use opendal::Operator;
1232    /// # use futures::StreamExt;
1233    /// # use futures::SinkExt;
1234    /// use bytes::Bytes;
1235    ///
1236    /// # async fn test(op: Operator) -> Result<()> {
1237    /// let mut w = op
1238    ///     .writer_with("path/to/file")
1239    ///     .user_metadata([
1240    ///         ("content-type".to_string(), "text/plain".to_string()),
1241    ///         ("author".to_string(), "OpenDAL".to_string()),
1242    ///     ])
1243    ///     .await?;
1244    /// w.write(vec![0; 4096]).await?;
1245    /// w.close().await?;
1246    /// # Ok(())
1247    /// # }
1248    /// ```
1249    pub fn user_metadata(mut self, data: impl IntoIterator<Item = (String, String)>) -> Self {
1250        self.args.user_metadata = Some(HashMap::from_iter(data));
1251        self
1252    }
1253}
1254
1255/// Future that generated by [`Operator::delete_with`].
1256///
1257/// Users can add more options by public functions provided by this struct.
1258pub type FutureDelete<F> = OperatorFuture<options::DeleteOptions, (), F>;
1259
1260impl<F: Future<Output = Result<()>>> FutureDelete<F> {
1261    /// Change the version of this delete operation.
1262    pub fn version(mut self, v: &str) -> Self {
1263        self.args.version = Some(v.to_string());
1264        self
1265    }
1266}
1267
1268/// Future that generated by [`Operator::deleter_with`].
1269///
1270/// Users can add more options by public functions provided by this struct.
1271pub type FutureDeleter<F> = OperatorFuture<OpDeleter, (), F>;
1272
1273/// Future that generated by [`Operator::list_with`] or [`Operator::lister_with`].
1274///
1275/// Users can add more options by public functions provided by this struct.
1276pub type FutureList<F> = OperatorFuture<options::ListOptions, Vec<Entry>, F>;
1277
1278impl<F: Future<Output = Result<Vec<Entry>>>> FutureList<F> {
1279    /// The limit passed to underlying service to specify the max results
1280    /// that could return per-request.
1281    ///
1282    /// Users could use this to control the memory usage of list operation.
1283    pub fn limit(mut self, v: usize) -> Self {
1284        self.args.limit = Some(v);
1285        self
1286    }
1287
1288    /// The start_after passes to underlying service to specify the specified key
1289    /// to start listing from.
1290    pub fn start_after(mut self, v: &str) -> Self {
1291        self.args.start_after = Some(v.to_string());
1292        self
1293    }
1294
1295    /// The recursive is used to control whether the list operation is recursive.
1296    ///
1297    /// - If `false`, list operation will only list the entries under the given path.
1298    /// - If `true`, list operation will list all entries that starts with given path.
1299    ///
1300    /// Default to `false`.
1301    pub fn recursive(mut self, v: bool) -> Self {
1302        self.args.recursive = v;
1303        self
1304    }
1305
1306    /// Controls whether the `list` operation should return file versions.
1307    ///
1308    /// This function allows you to specify if the `list` operation, when executed, should include
1309    /// information about different versions of files, if versioning is supported and enabled.
1310    ///
1311    /// If `true`, subsequent `list` operations will include version information for each file.
1312    /// If `false`, version information will be omitted from the `list` results.
1313    ///
1314    /// Default to `false`
1315    pub fn versions(mut self, v: bool) -> Self {
1316        self.args.versions = v;
1317        self
1318    }
1319
1320    /// Controls whether the `list` operation should include deleted files (or versions).
1321    ///
1322    /// This function allows you to specify if the `list` operation, when executed, should include
1323    /// entries for files or versions that have been marked as deleted. This is particularly relevant
1324    /// in object storage systems that support soft deletion or versioning.
1325    ///
1326    /// If `true`, subsequent `list` operations will include deleted files or versions.
1327    /// If `false`, deleted files or versions will be excluded from the `list` results.
1328    pub fn deleted(mut self, v: bool) -> Self {
1329        self.args.deleted = v;
1330        self
1331    }
1332}
1333
1334/// Future that generated by [`Operator::list_with`] or [`Operator::lister_with`].
1335///
1336/// Users can add more options by public functions provided by this struct.
1337pub type FutureLister<F> = OperatorFuture<options::ListOptions, Lister, F>;
1338
1339impl<F: Future<Output = Result<Lister>>> FutureLister<F> {
1340    /// The limit passed to underlying service to specify the max results
1341    /// that could return per-request.
1342    ///
1343    /// Users could use this to control the memory usage of list operation.
1344    pub fn limit(mut self, v: usize) -> Self {
1345        self.args.limit = Some(v);
1346        self
1347    }
1348
1349    /// The start_after passes to underlying service to specify the specified key
1350    /// to start listing from.
1351    pub fn start_after(mut self, v: &str) -> Self {
1352        self.args.start_after = Some(v.to_string());
1353        self
1354    }
1355
1356    /// The recursive is used to control whether the list operation is recursive.
1357    ///
1358    /// - If `false`, list operation will only list the entries under the given path.
1359    /// - If `true`, list operation will list all entries that starts with given path.
1360    ///
1361    /// Default to `false`.
1362    pub fn recursive(mut self, v: bool) -> Self {
1363        self.args.recursive = v;
1364        self
1365    }
1366
1367    /// Controls whether the `list` operation should return file versions.
1368    ///
1369    /// This function allows you to specify if the `list` operation, when executed, should include
1370    /// information about different versions of files, if versioning is supported and enabled.
1371    ///
1372    /// If `true`, subsequent `list` operations will include version information for each file.
1373    /// If `false`, version information will be omitted from the `list` results.
1374    ///
1375    /// Default to `false`
1376    pub fn versions(mut self, v: bool) -> Self {
1377        self.args.versions = v;
1378        self
1379    }
1380
1381    /// Controls whether the `list` operation should include deleted files (or versions).
1382    ///
1383    /// This function allows you to specify if the `list` operation, when executed, should include
1384    /// entries for files or versions that have been marked as deleted. This is particularly relevant
1385    /// in object storage systems that support soft deletion or versioning.
1386    ///
1387    /// If `true`, subsequent `list` operations will include deleted files or versions.
1388    /// If `false`, deleted files or versions will be excluded from the `list` results.
1389    pub fn deleted(mut self, v: bool) -> Self {
1390        self.args.deleted = v;
1391        self
1392    }
1393}
1394
1395/// Future that generated by [`Operator::copy_with`].
1396///
1397/// Users can add more options by public functions provided by this struct.
1398pub type FutureCopy<F> = OperatorFuture<(options::CopyOptions, String), (), F>;
1399
1400impl<F: Future<Output = Result<()>>> FutureCopy<F> {
1401    /// Sets the condition that copy operation will succeed only if target does not exist.
1402    ///
1403    /// Refer to [`options::CopyOptions::if_not_exists`] for more details.
1404    ///
1405    /// ### Example
1406    ///
1407    /// ```
1408    /// # use opendal::Result;
1409    /// # use opendal::Operator;
1410    ///
1411    /// # async fn test(op: Operator) -> Result<()> {
1412    /// let _ = op
1413    ///     .copy_with("source/path", "target/path")
1414    ///     .if_not_exists(true)
1415    ///     .await?;
1416    /// # Ok(())
1417    /// # }
1418    /// ```
1419    pub fn if_not_exists(mut self, v: bool) -> Self {
1420        self.args.0.if_not_exists = v;
1421        self
1422    }
1423}
```
