# Schema-to-UI Conversion Guide

This document describes how database schemas are converted into interactive UI components in MudRock, specifically focusing on the AG-Grid data table system.

## üèóÔ∏è Architecture Overview

```
Database Schema ‚Üí Rust Backend ‚Üí TypeScript Types ‚Üí AG-Grid Column Definitions ‚Üí Interactive UI
```

## üìã Complete Schema-to-UI Flow

### 1. **Schema Definition Phase**

#### **Hardcoded Schema Location**: `src-tauri/src/postgres_query/hardcoded_schema.rs`

The system uses predefined schemas rather than dynamic discovery:

```rust
pub struct HardcodedSchema {
    // Static data provider - no fields needed
}

impl HardcodedSchema {
    pub fn get_dump_animals_schema() -> TableSchema {
        TableSchema {
            table_name: "dump_animals".to_string(),
            columns: vec![
                ColumnInfo {
                    column_name: "id".to_string(),
                    data_type: "integer".to_string(),
                    is_nullable: "NO".to_string(),
                    column_default: Some("nextval('dump_animals_id_seq'::regclass)".to_string()),
                    character_maximum_length: None,
                },
                ColumnInfo {
                    column_name: "pet_name".to_string(),
                    data_type: "character varying".to_string(),
                    is_nullable: "NO".to_string(),
                    column_default: None,
                    character_maximum_length: Some(100),
                },
                // ... more columns
            ],
        }
    }
}
```

#### **Schema Types**:

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct ColumnInfo {
    pub column_name: String,
    pub data_type: String,
    pub is_nullable: String,
    pub column_default: Option<String>,
    pub character_maximum_length: Option<i32>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TableSchema {
    pub table_name: String,
    pub columns: Vec<ColumnInfo>,
}
```

### 2. **Schema Fetching Phase**

#### **Frontend Request**: `src/lib/tauri-commands/schema-fetching.ts`

```typescript
export async function fetchTableSchema(
  tableName: string,
): Promise<TableSchema> {
  try {
    console.log(`üîç Fetching schema for table: ${tableName}`);
    const schema = await invoke<TableSchema>("fetch_table_schema", {
      tableName,
    });
    console.log(
      `‚úÖ Table schema fetched successfully for ${tableName}:`,
      schema,
    );
    return schema;
  } catch (error) {
    console.error(`‚ùå Error fetching table schema for ${tableName}:`, error);
    throw new Error(`Failed to fetch table schema for ${tableName}: ${error}`);
  }
}
```

#### **Backend Handler**: `src-tauri/src/main.rs`

```rust
#[tauri::command]
async fn fetch_table_schema(table_name: String) -> Result<serde_json::Value, String> {
    println!("üöÄ Starting fetch_table_schema command for table: {}", table_name);

    let schema_fetcher = SchemaFetcher::new();
    match schema_fetcher.fetch_table_schema(&table_name).await {
        Ok(schema) => {
            println!("‚úÖ Successfully fetched schema for table: {} with {} columns",
                     table_name, schema.columns.len());
            Ok(serde_json::to_value(schema).unwrap_or_else(|e| {
                println!("‚ùå Error serializing table schema: {}", e);
                serde_json::Value::Null
            }))
        }
        Err(e) => {
            println!("‚ùå Error fetching table schema for {}: {}", table_name, e);
            Err(format!("Failed to fetch table schema for {}: {}", table_name, e))
        }
    }
}
```

### 3. **Schema Processing Phase**

#### **Column Definition Generation**: `src/lib/tauri-commands/schema-fetching.ts`

```typescript
export function generateColumnDefsFromSchema(schema: TableSchema): any[] {
  return schema.columns.map((column) => {
    // Determine if column should be editable (not auto-generated)
    const isAutoGenerated =
      column.column_name === "id" ||
      column.column_name === "created_at" ||
      column.column_name === "updated_at" ||
      column.column_default?.includes("nextval") ||
      column.column_default?.includes("now()");

    const baseColumn = {
      field: column.column_name,
      headerName:
        column.column_name.charAt(0).toUpperCase() +
        column.column_name.slice(1),
      editable: !isAutoGenerated,
      suppressHeaderMenuButton: false,
      suppressHeaderContextMenu: false,
    };

    // Add type-specific formatting and configuration
    switch (column.data_type) {
      case "timestamp with time zone":
      case "timestamp without time zone":
      case "date":
        return {
          ...baseColumn,
          width: 150,
          filter: "agDateColumnFilter",
          valueFormatter: (params: any) => {
            if (!params.value) return "-";
            return new Date(params.value).toLocaleDateString();
          },
          sort: column.column_name === "created_at" ? "desc" : undefined,
        };

      case "integer":
      case "bigint":
      case "smallint":
        return {
          ...baseColumn,
          width: 100,
          filter: "agNumberColumnFilter",
          valueFormatter: (params: any) => {
            return params.value?.toString() || "-";
          },
          sort: column.column_name === "id" ? "asc" : undefined,
        };

      case "character varying":
        return {
          ...baseColumn,
          width: column.character_maximum_length
            ? Math.min(column.character_maximum_length * 8, 300)
            : 150,
          filter: "agTextColumnFilter",
          valueFormatter: (params: any) => {
            if (params.value === null || params.value === undefined) return "-";
            return String(params.value);
          },
        };

      default:
        return {
          ...baseColumn,
          width: 150,
          filter: "agTextColumnFilter",
          valueFormatter: (params: any) => {
            if (params.value === null || params.value === undefined) return "-";
            return String(params.value);
          },
        };
    }
  });
}
```

### 4. **AG-Grid Integration Phase**

#### **Component Integration**: `src/lib/components/pages/home/content-main/content-data/AG-data-table/AG-data-table.svelte`

```typescript
// Watch for changes in selected table
$effect(() => {
  if (dataTableState?.currentSelectedTable) {
    console.log(
      "üîÑ AG-Grid: Selected table changed to:",
      dataTableState.currentSelectedTable,
    );
    loadTableData(dataTableState.currentSelectedTable);
  }
});

async function loadTableData(tableName: string) {
  try {
    console.log("üîÑ AG-Grid: Loading data for table:", tableName);
    isLoading = true;
    error = null;

    // Fetch both data and schema in parallel
    const [data, schema] = await Promise.all([
      import("$lib/tauri-commands/table-data-fetching").then((m) =>
        m.getTableData(tableName),
      ),
      fetchTableSchema(tableName),
    ]);

    tableData = data;

    // Generate column definitions based on schema (more accurate than data-based)
    const baseColumnDefs = generateColumnDefsFromSchema(schema);

    // Apply column states to make id and auto-generated fields non-editable
    columnDefs = columnStateManager.applyColumnStates(baseColumnDefs);

    console.log("‚úÖ AG-Grid: Schema-based column definitions:", columnDefs);
  } catch (err) {
    console.error("‚ùå AG-Grid: Failed to load data:", err);
    error = err instanceof Error ? err.message : "Failed to load table data";
  } finally {
    isLoading = false;
  }
}
```

### 5. **UI Rendering Phase**

#### **AG-Grid Configuration**:

```typescript
let gridOptions = $state<GridOptions>({
  defaultColDef: {
    enableCellChangeFlash: true,
    suppressMovable: true,
    resizable: true,
    sortable: true,
    editable: true, // Make all columns editable by default
    flex: 1,
    minWidth: 150,
    filter: "agTextColumnFilter", // Default filter for all columns
    suppressHeaderMenuButton: false,
    suppressHeaderContextMenu: false,
  },
  columnDefs: [], // Populated from schema
  getRowId: (params) => {
    return params.data.id
      ? params.data.id.toString()
      : `row-${Math.random().toString(36).substr(2, 9)}`;
  },
  theme: themeQuartz.withParams({
    accentColor: "#3B82F6",
  }),
  autoSizeStrategy: {
    type: "fitCellContents",
  },
  pagination: true,
  paginationPageSizeSelector: [10, 20, 50, 100],
  paginationPageSize: 20,
  cellSelection: true,
  singleClickEdit: true,
  stopEditingWhenCellsLoseFocus: true,
  editType: "fullRow",
  suppressContextMenu: false,
  // ... more configuration
});
```

## üéØ **Schema-to-UI Mapping**

| PostgreSQL Type     | AG-Grid Configuration                             | UI Behavior                       |
| ------------------- | ------------------------------------------------- | --------------------------------- |
| `integer/bigint`    | Number filter, 100px width, ascending sort for ID | Numeric input, number filtering   |
| `timestamp`         | Date filter, 150px width, date formatter          | Date picker, date range filtering |
| `character varying` | Text filter, dynamic width based on max length    | Text input, text search           |
| `boolean`           | Set filter (Yes/No), 80px width                   | Checkbox, dropdown selection      |
| `geometry`          | Text formatter, 200px width                       | Read-only display                 |
| `json/jsonb`        | JSON string formatter, 200px width                | Read-only JSON display            |

## üîß **Key Features**

### **Type-Aware Rendering**

- **Numeric Types**: Number filters, proper formatting, sorting
- **Date Types**: Date pickers, date range filtering, localized formatting
- **Text Types**: Text search, dynamic width based on constraints
- **Boolean Types**: Dropdown selection, clear visual indicators

### **Editability Rules**

- **Auto-generated fields**: `id`, `created_at`, `updated_at` are read-only
- **Sequence fields**: Fields with `nextval()` are non-editable
- **User data**: All other fields are editable with proper validation

### **Performance Optimizations**

- **Schema-based generation**: More accurate than data inspection
- **Parallel loading**: Data and schema fetched simultaneously
- **Efficient rendering**: Only affected components re-render
- **Memory management**: Minimal allocations, reuses existing structures

### **User Experience**

- **Intuitive editing**: Single-click editing, proper input types
- **Advanced filtering**: Type-specific filters for each column
- **Context menus**: Right-click operations for row management
- **Visual feedback**: Loading states, error handling, success indicators

## üöÄ **Benefits of This Approach**

1. **Type Safety**: End-to-end TypeScript/Rust type checking
2. **Performance**: Optimized for large datasets with pagination
3. **Flexibility**: Easy to add new column types and behaviors
4. **Maintainability**: Clear separation of concerns
5. **User Experience**: Intuitive, responsive interface
6. **Scalability**: Handles complex schemas with many columns

## üîÑ **Complete Data Flow**

1. **User Action**: Selects table from sidebar
2. **Schema Request**: Frontend calls `fetchTableSchema(tableName)`
3. **Backend Processing**: Rust returns hardcoded schema
4. **Column Generation**: TypeScript converts schema to AG-Grid definitions
5. **Data Loading**: Parallel fetch of actual table data
6. **UI Rendering**: AG-Grid renders with proper column types and behaviors
7. **User Interaction**: Editing, filtering, sorting with type-aware controls

This architecture provides a robust, performant, and maintainable schema-to-UI conversion system that scales well with complex database schemas while maintaining excellent user experience! üéâ
